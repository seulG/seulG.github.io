<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://seulg.github.io/</id>
    <title>Seul</title>
    <updated>2020-07-07T17:19:32.422Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://seulg.github.io/"/>
    <link rel="self" href="https://seulg.github.io/atom.xml"/>
    <subtitle>为了活着而活着</subtitle>
    <logo>https://seulg.github.io/images/avatar.png</logo>
    <icon>https://seulg.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Seul</rights>
    <entry>
        <title type="html"><![CDATA[MyBatis入门]]></title>
        <id>https://seulg.github.io/post/mybatis-ru-men/</id>
        <link href="https://seulg.github.io/post/mybatis-ru-men/">
        </link>
        <updated>2020-07-06T13:52:08.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="mybatis">MyBatis</h2>
<p>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p>
<h3 id="简介">简介</h3>
<p>实现了ORMapping: Object Relationship Mapping 对象关系映射，其中对象指面向对象，关系指关系型数据库</p>
<p>Java到MYSQL的映射，开发者可以以面向对象的思想管理数据库。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="mybatis">MyBatis</h2>
<p>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p>
<h3 id="简介">简介</h3>
<p>实现了ORMapping: Object Relationship Mapping 对象关系映射，其中对象指面向对象，关系指关系型数据库</p>
<p>Java到MYSQL的映射，开发者可以以面向对象的思想管理数据库。</p>
<!-- more -->
<h3 id="优点">优点</h3>
<ol>
<li>与JDBC相比，减少了50%以上的代码量</li>
<li>MyBatis是最简单的持久化框架，小巧并且简单易学</li>
<li>MyBatis相当灵活，不会队应用程序或者数据库的现有设计强加任何影响。SQL写在XML里，从程序中彻底分离，降低耦合度，便于统一管理和优化，并可重用。</li>
<li>提供XML标签，支持编写动态的SQL语句。</li>
<li>提供XML映射标签，支持对象与数据库的ORM字段关系映射。</li>
</ol>
<p>Tips：DButils也实现了的ORM映射</p>
<h4 id="缺点">缺点</h4>
<ol>
<li>SQL写在XML里面，对sql语句的基础要求高</li>
<li>SQL语句针对特定的数据库，因此不能轻易更换数据库</li>
</ol>
<h3 id="project-lombok">ProJect LomBok</h3>
<h4 id="简介-2"><a href="https://projectlombok.org/">简介</a></h4>
<p><code>Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java. Never write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more.</code></p>
<p>Project Lombok是一个Java^(TM)实用工具，可用来帮助开发者消除Java中的冗长代码，尤其是对简单Java对象(POJO)，它通过注解实现这一目的。总结一句话，就是简单的注释，替代get set等方法。</p>
<h4 id="原理">原理</h4>
<p>Lombok的原理设计到了JDK6的JSR269规范(插入化注解API)，具体简介可以看这篇<a href="https://blog.csdn.net/ni_hao_fan/article/details/99445073">博客</a>，这里仅提供简单的介绍：</p>
<p>JSR269规范提供了一系列标准API去处理Java的Annotation(注解)，JSR 269用Annotation Processor实现了在<strong>编译期</strong>而非运行期对注解的处理，也就是说，当javac把java文件编译为class文件时，就能处理注解的内容，相当于是编译器的一个插件这就是插入式注解名字的由来，编译器会调用<code>Annotation Processor</code>方法，如果产生了新的Java代码，编译器会再调用一次，直到没有新的代码产生。</p>
<p><strong>注意区分Spring的注解是运行时执行的注解，Lombok是编译期注解</strong></p>
<p>总结：也就是说Lombok可以让javac去生成相应的get和set等方法，并编译</p>
<h4 id="安装">安装：</h4>
<p>此处可以参考官网install条目，一下仅仅展示Maven+IDEA的安装过程</p>
<ol>
<li>maven项目中要导入相应的坐标</li>
</ol>
<p>Maven坐标：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
    &lt;artifactId&gt;lombok&lt;/artifactId&gt;
    &lt;version&gt;1.18.6&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
<li>安装IDEA插件，再Pluing中搜索Lombok ,安装插件(必须安装，否则IDEA会报错)
<ol>
<li>此处若搜索不出来，可以去IDEA官网下载对应版本的插件，本地安装即可</li>
<li>重启完IDEA，给实体类添加<code>@Data</code>注解，点击侧边栏<code>Structure</code>就可以看到注解所添加的方法</li>
</ol>
</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2020/07/06/QcqIi2VhDpOf1kx.png" alt="image-20200706235909064" loading="lazy"></figure>
<h4 id="常用注解详解">常用注解详解</h4>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2020/07/06/tfJ2rOY8c5EAbaM.png" alt="image-20200706235941538" loading="lazy"></figure>
<blockquote>
<p>@Getter &amp; @Setter</p>
</blockquote>
<ul>
<li><code>@Getter</code>
<ul>
<li>默认是public</li>
<li>可以设置访问级别，例：<code>@Getter(AccessLevel.PROTEVTED)</code></li>
</ul>
</li>
<li><code>@Setter</code>
<ul>
<li>默认public，参数默认增加了<code>final</code>修饰符</li>
</ul>
</li>
<li>作用范围
<ul>
<li>给成员变量设置，就仅仅给该成员变量设置相应方法</li>
<li>给类添加，则能给所有成员变量都生成getter和setter方法</li>
</ul>
</li>
<li>有<code>static</code>修饰的成员变量
<ul>
<li>则注解不会对该变量生成</li>
</ul>
</li>
<li>有<code>final</code>修饰的成员变量
<ul>
<li>仅仅会生成getter方法</li>
</ul>
</li>
<li>若要排除某个成员变量
<ul>
<li>只需要将该成员变量的访问级别设置为NULL</li>
<li><code>Getter(AccessLevel.NONE)</code></li>
<li><code>Setter(AccessLevel.NONE)</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>@ToString</p>
</blockquote>
<ul>
<li>作用范围：
<ul>
<li>只能写在类上</li>
<li>同样不会作用于有<code>static</code>修饰的变量</li>
</ul>
</li>
<li>重写了<code>toString()</code>方法</li>
<li>用exclude属性排除字段
<ul>
<li><code>@ToString(exclude={&quot;name&quot;,&quot;id&quot;})</code></li>
</ul>
</li>
<li>用of属性指定输出字段
<ul>
<li><code>@ToString(of={&quot;id&quot;,&quot;name&quot;})</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>@EqualsAndHashCode</p>
</blockquote>
<ul>
<li>会生成，equals()方法，canEquals()，hashCode()方法</li>
<li>通过exclude属性，排除某些属性</li>
<li>通过of属性，指定判断的属性</li>
<li>equals()，按以下顺序判断
<ul>
<li>会比较两个对象是不是同一个对象，是true</li>
<li>不是会比较是不是同类对象，不是就false</li>
<li>是可以比较的就会判断成员变量是否相等
<ul>
<li>全一样才true</li>
</ul>
</li>
</ul>
</li>
<li>canEquals()
<ul>
<li>判断是否为同类对象</li>
<li>是true，否false</li>
</ul>
</li>
<li>hashCode()
<ul>
<li>根据类里的所有字段生成hashCode</li>
<li>如果实现了此方法，就可以通过hashCode判断两个对象是否为一个对象</li>
</ul>
</li>
</ul>
<blockquote>
<p>@NonNull</p>
</blockquote>
<ul>
<li>作用于成员方法上时，写在参数列表里
<ul>
<li>例：<code>public void (@NonNull String str)</code></li>
</ul>
</li>
<li>给字段设置@NonNull，写在字段的修饰符前</li>
</ul>
<blockquote>
<p>@NoArgsConstructor &amp; RequiredArgsConstructor &amp; @AllArgsConstructor</p>
</blockquote>
<ul>
<li>给类设置构造参数</li>
<li>RequiredArgsConstructor 会去寻找有<code>@NonNul</code>l标记的和<code>final</code>修饰的<strong>无初始值</strong>的字段作为构造函数的参数列表</li>
<li>AllArgsConstructor顾名思义</li>
</ul>
<blockquote>
<p>@Data</p>
</blockquote>
<ul>
<li>全能注解，囊括了之前的所有标签的作用</li>
<li>构造函数实现的是RequiredArgsConstructor</li>
</ul>
<blockquote>
<p>@Build</p>
</blockquote>
<ul>
<li>
<p>生成一个内部类( 类名Builder)，以字段名为方法名去构造了一系列方法</p>
</li>
<li>
<p>返回的对象为  类名Builder</p>
</li>
<li>
<p>实际上是给类提供了一个build的生成方式</p>
<p><code>User user = UserBulider.name(&quot;&quot;).id.date(&quot;&quot;).bulid()</code></p>
</li>
</ul>
<blockquote>
<p>@Log</p>
</blockquote>
<p>设置了一个log成员变量，直接在想要输出日志的方法里写</p>
<p><code>log.info(&quot;&quot;)</code>即可</p>
<blockquote>
<p>val</p>
</blockquote>
<p>关键子类型，不会限制变量类型</p>
<p><code>var map = new HashMap&lt;String,String&gt;()</code></p>
<blockquote>
<p>@Cleanup</p>
</blockquote>
<ul>
<li>关闭资源</li>
<li>给需要关闭的资源加上@Cleanup，lombol就会在是用完，自动释放资源</li>
</ul>
<h3 id="mybatis核心类">MyBatis核心类</h3>
<figure data-type="image" tabindex="3"><img src="https://s1.ax1x.com/2020/07/06/UiOwO1.png" alt="UiOwO1.png" loading="lazy"></figure>
<h4 id="怎么使用">怎么使用</h4>
<p>Maven导入依赖，MyBatis是队JDBC的封装，但是没有取代JDBC，因此链接数据库仍然要导入mysql的依赖,lombok是简化实体类的开发</p>
<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
        &lt;version&gt;3.4.5&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;8.0.11&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;version&gt;1.18.6&lt;/version&gt;
        &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;!--        c3p0连接池--&gt;
    &lt;!-- https://mvnrepository.com/artifact/com.mchange/c3p0 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.mchange&lt;/groupId&gt;
        &lt;artifactId&gt;c3p0&lt;/artifactId&gt;
        &lt;version&gt;0.9.5.5&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
&lt;!--让程序能读取到非resource文件夹的配置文件--&gt;
&lt;build&gt;
    &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/java&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
&lt;/build&gt;
</code></pre>
<ul>
<li>创建新的表</li>
</ul>
<pre><code class="language-sql">use springioc;
create table mybatis(
    id int primary key auto_increment,
    username varvhar(11)
    password varvhar(11)
    age int
)
</code></pre>
<ul>
<li>创建实体类</li>
</ul>
<pre><code class="language-java">package com.henu.entity;

import lombok.Data;

@Data
public class User {
    private long id;
    private String username;
    private String password;
    private int age;
}
</code></pre>
<ul>
<li>创建Mybatis配置文件</li>
</ul>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;!--配置mybatis运行环境--&gt;
    &lt;environments default=&quot;development&quot;&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;!--配置JDBC事务管理--&gt;
            &lt;transactionManager type=&quot;JDBC&quot;/&gt;
            &lt;!--配置JDBC数据源连接池--&gt;
            &lt;dataSource type=&quot;com.henu.utils.c3p0DataSourceFactory&quot;&gt;
                &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
                &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/springioc?serverTimezone=GMT%2B8&quot;/&gt;
                &lt;property name=&quot;user&quot; value=&quot;root&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;gyg06103234&quot;/&gt;
                &lt;!--配置初始连接数--&gt;
                &lt;property name=&quot;initialPoolSize&quot; value=&quot;5&quot;/&gt;
                &lt;!--配置最大保留连接数--&gt;
                &lt;property name=&quot;maxPoolSize&quot; value=&quot;20&quot;/&gt;
                &lt;!--配置最小保留连接数--&gt;
                &lt;property name=&quot;minPoolSize&quot; value=&quot;5&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;!--    注册UserMapper.xml--&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;com/henu/mapper/UserMapper.xml&quot;/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<p>注意此处整合c3p0,需要，dataSource必须是实现了DataSourceFactory接口的子类</p>
<p>其中自定义类<code>c3p0DataSourceFactory</code>继承自<code>UnpooledDataSourceFactory</code>，<code>UnpooledDataSourceFactory</code>实现了<code>DataSourceFactory</code>接口，并且有一个成员变量<code>dataSource</code></p>
<pre><code class="language-java">package com.henu.utils;

import com.mchange.v2.c3p0.ComboPooledDataSource;
import org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory;

public class c3p0DataSourceFactory extends UnpooledDataSourceFactory {
    //自定义的构造方法
    public c3p0DataSourceFactory() {
        //从父类继承过来的成员变量dataSource，右边是创建一个c3p0的数据库连接池对象。
        //需要提供一个c3p0.xml配置文件
        this.dataSource=new ComboPooledDataSource();
    }
}
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://i.loli.net/2020/07/07/6aHEPckqdiX5s37.png" alt="image-20200707100531559" loading="lazy"></figure>
<h4 id="两种方式">两种方式</h4>
<blockquote>
<p>使用原生接口</p>
</blockquote>
<p>MyBatis框架需要开发者自定义SQL语句，写在Mapper.xml文件中，实际开发中，会为每个实体类创建对应的Mapper.xml，定义管理该对象数据SQl语句</p>
<ol>
<li>创建Mapper.xml文件</li>
</ol>
<pre><code class="language-xml">&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.henu.mapper.UserMapper&quot;&gt;
    &lt;insert id=&quot;save&quot; parameterType=&quot;com.henu.entity.User&quot;&gt;
        insert into mybatis(username,password,age) value (#{username},#{password},#{age})
    &lt;/insert&gt;
&lt;/mapper&gt;
</code></pre>
<ul>
<li>namespace 通常设置为⽂件所在包+⽂件名的形式。</li>
<li>insert 标签表示执⾏添加操作。</li>
<li>select 标签表示执⾏查询操作。</li>
<li>update 标签表示执⾏更新操作。</li>
<li>delete 标签表示执⾏删除操作。</li>
<li>id 是实际调⽤ MyBatis ⽅法时需要⽤到的参数。</li>
<li>parameterType 是调⽤对应⽅法时参数的数据类型。</li>
</ul>
<ol start="2">
<li>在全局配置文件中注册UserMapper.xml</li>
</ol>
<pre><code class="language-xml">&lt;!--    注册UserMapper.xml--&gt;
&lt;mappers&gt;
    &lt;mapper resource=&quot;com/henu/mapper/UserMapper.xml&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<ol start="3">
<li>调用原生接口</li>
</ol>
<pre><code class="language-java">package com.henu.test;

import com.henu.entity.User;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import java.io.InputStream;

public class Main {
    public static void main(String[] args) {
        //        加载配置文件
        InputStream res = Main.class.getClassLoader().getResourceAsStream(&quot;mybatis.xml&quot;);
        SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();
        SqlSessionFactory factory = builder.build(res);
        SqlSession sqlSession = factory.openSession();
        //com.henu.mapper.UserMapper为mapper的命名空间
        //save为方法id
        String statement = &quot;com.henu.mapper.UserMapper.save&quot;;
        User user = new User(1L, &quot;admin&quot;, &quot;gyg&quot;, 20);
        sqlSession.insert(statement,user);
        //提交事务
        sqlSession.commit();
    }
}
</code></pre>
<blockquote>
<p>通过Mapper代理实现自定义接口</p>
</blockquote>
<ul>
<li>自定义接口，定义相关业务方法</li>
<li>编写与方法相对应的Mapper.xml</li>
</ul>
<ol>
<li>自定义接口</li>
</ol>
<pre><code class="language-java">package com.henu.repository;

import com.henu.entity.User;

import java.util.List;

public interface AccountRepository {
    int save(User user);
    int update(User user);
    int deleteById(long id);
    List&lt;User&gt; findAll();
    User findById(long id);
}
</code></pre>
<ol start="2">
<li>创建接口对应的Mapper.xml，定义接口方法对应的SQL语句</li>
</ol>
<ul>
<li>
<p>statement 标签可根据 SQL 执⾏的业务选择 insert、delete、update、select。</p>
</li>
<li>
<p>MyBatis 框架会根据规则⾃动创建接⼝实现类的代理对象。</p>
</li>
</ul>
<p>规则：</p>
<ul>
<li>Mapper.xml 中 namespace 为接⼝的全类名。</li>
<li>Mapper.xml 中 statement 的 id 为接⼝中对应的⽅法名。</li>
<li>Mapper.xml 中 statement 的 parameterType 和接⼝中对应⽅法的参数类型⼀致。</li>
<li>Mapper.xml 中 statement 的 resultType 和接⼝中对应⽅法的返回值类型⼀致。
<ul>
<li>若返回值为int，可以不写</li>
<li>若返回值为一个集合，则配置集合泛型即可，不用配置集合类型</li>
</ul>
</li>
</ul>
<pre><code class="language-xml">&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.henu.repository.AccountRepository&quot;&gt;
    &lt;insert id=&quot;save&quot; parameterType=&quot;com.henu.entity.User&quot;&gt;
        insert into mybatis(username, password, age) value (#{usernaem},#{password},#{age})
    &lt;/insert&gt;
    &lt;update id=&quot;update&quot; parameterType=&quot;com.henu.entity.User&quot;&gt;
        update mybatis set username = #{username}, password = #{password}, age = #{age} where id = #{id}
    &lt;/update&gt;
    &lt;delete id=&quot;deleteById&quot; parameterType=&quot;long&quot; &gt;
        delete from mybatis where id = #{id}
    &lt;/delete&gt;
    &lt;select id=&quot;findAll&quot; resultType=&quot;com.henu.entity.User&quot;&gt;
        select * from mybatis
    &lt;/select&gt;
    &lt;select id=&quot;findById&quot; parameterType=&quot;long&quot; resultType=&quot;com.henu.entity.User&quot;&gt;
        select * from mybatis where id = #{id}
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<ol start="3">
<li>在全局配置中(mybits.xml)注册</li>
</ol>
<pre><code class="language-xml">&lt;mapper resource=&quot;com/henu/repository/AccountRepository.xml&quot; /&gt;
</code></pre>
<ol start="4">
<li>获取MaBits框架动态生成的代理类，调用接口方法<code>getMapper</code></li>
</ol>
<pre><code class="language-java">package com.henu.test;

import com.henu.entity.User;
import com.henu.repository.AccountRepository;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import java.io.InputStream;
import java.util.List;

public class TestForMapper {
    public static void main(String[] args) {
        InputStream res = TestForMapper.class.getClassLoader().getResourceAsStream(&quot;mybatis.xml&quot;);
        SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();
        SqlSessionFactory factory = builder.build(res);
        SqlSession sqlSession = factory.openSession();
        //获取实现接口的代理对象
        AccountRepository mapper = sqlSession.getMapper(AccountRepository.class);
        //直接调用接口的方法即可
        //        List&lt;User&gt; all = mapper.findAll();
        //        for (User user : all) {
        //            System.out.println(user);
        //        }
        User user = new User(1L,&quot;MyBatis&quot;,&quot;gyg&quot;,18);
        //        mapper.save(user);
        //        mapper.deleteById(7);
        //        User byId = mapper.findById(5);
        //        System.out.println(byId);
        //        数据发生改变的时候一定要提交事务
        mapper.update(user);
        sqlSession.commit();
    }
}
</code></pre>
<h3 id="mapperxml详解">Mapper.xml详解</h3>
<ul>
<li>statement标签：select、update、delete、insert这些标签分别对应查询，修改，删除，插入操作</li>
<li>parameterType：参数类型
<ol>
<li>基本数据类型，直接写关键字即可<code>int char double float</code></li>
<li>String类型要传入全路径类名<code>java.lang.String</code></li>
<li>包装类类型，要传入全路径类名</li>
<li>多个参数，就不用设定parameterType，此时取参数需要用<code>#{param1}</code>或者<code>#{arg0}</code>
<ul>
<li>param从1开始</li>
<li>arg从0开始</li>
</ul>
</li>
<li>Java Bean作为参数，写其全路径类名</li>
</ol>
</li>
<li>resultType：结果类型
<ol>
<li>基本数据类型，写关键字</li>
<li>包装类，写全路径类名</li>
<li>列表类型，写泛型的全路径类名</li>
<li>Java Bean，写全路径类名</li>
</ol>
</li>
</ul>
<h3 id="级联查询">级联查询</h3>
<p>这里的ROM，不是实体类和表的直接映射，而是<strong>结果集和类的映射</strong></p>
<h4 id="一对多">一对多</h4>
<ul>
<li>创建学生和班级表</li>
</ul>
<pre><code class="language-sql">use springioc;
CREATE TABLE student(
    id int primary key auto_increment,
    name varchar(11),
    cid int
)
</code></pre>
<pre><code class="language-sql">use springioc;
CREATE TABLE classes(
    id int primary key auto_increment,
    name varchar(11)
)
</code></pre>
<ul>
<li>插入几条数据</li>
</ul>
<pre><code class="language-sql">use springioc;
INSERT INTO student (name,cid) VALUES(&quot;张三&quot;,1);
INSERT INTO student (name,cid) VALUES(&quot;李四&quot;,2);
INSERT INTO student (name,cid) VALUES(&quot;王五&quot;,2);
INSERT INTO student (name,cid) VALUES(&quot;小明&quot;,1);

INSERT INTO classes (id,name) VALUES(1,&quot;一班&quot;);
INSERT INTO classes (id,name) VALUES(2,&quot;二班&quot;);
INSERT INTO classes (id,name) VALUES(3,&quot;三班&quot;);
</code></pre>
<ul>
<li>创建两个实体类</li>
</ul>
<pre><code class="language-java">package com.henu.entity;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class Student {
    private long id;
    private String name;
    private Classes classes;
}
</code></pre>
<pre><code class="language-java">package com.henu.entity;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class Classes {
    private long id;
    private String name;
    private List&lt;Student&gt; students;
}
</code></pre>
<p>事务需求，在查询学生的时候，查出其班级</p>
<pre><code class="language-sql">use springioc;
SELECT s.id,s.`name`,c.`name` as cname FROM student s, classes c WHERE s.id=1 and c.id=s.cid
</code></pre>
<ul>
<li>通过上述案例请手动写出获取Mapper对象 以及xml，接口编写，不要忘记注册mapper.xml</li>
</ul>
<p>此时我们需要用<code>resultMap</code>标签</p>
<pre><code class="language-xml">&lt;resultMap id=&quot;studenMap&quot; type=&quot;com.henu.entity.Student&quot;&gt;
    &lt;!--        主键映射用id--&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
    &lt;!--        其他字段用result--&gt;
    &lt;result column=&quot;name&quot; property=&quot;name&quot; /&gt;
    &lt;!--        联合其他表的时候需要使用次标签 javaType为其他表对应实体类的类型--&gt;
    &lt;association property=&quot;classes&quot; javaType=&quot;com.henu.entity.Classes&quot; &gt;
        &lt;!--            其他表的主键--&gt;
        &lt;id column=&quot;cid&quot; property=&quot;id&quot;/&gt;
        &lt;!--            其他表的普通字段--&gt;
        &lt;result column=&quot;cname&quot; property=&quot;name&quot;/&gt;
    &lt;/association&gt;
&lt;/resultMap&gt;
&lt;select id=&quot;findClasses&quot; parameterType=&quot;long&quot; resultMap=&quot;studenMap&quot;&gt;
    select s.id, s.name, c.name as cname from student s,classes c where s.id = #{id} and s.cid = c.id
&lt;/select&gt;
</code></pre>
<h4 id="多对一">多对一</h4>
<pre><code class="language-sql">use springioc;
SELECT c.id, c.name, s.name as sname FROM student s, classes c WHERE c.id = 1 and c.id = s.cid
</code></pre>
<p>参照上述一对多案例不难写出，多对一的<code>resultMap</code></p>
<pre><code class="language-xml">&lt;resultMap id=&quot;classesMap&quot; type=&quot;com.henu.entity.Classes&quot;&gt;
    &lt;id column=&quot;cid&quot; property=&quot;id&quot;/&gt;
    &lt;result column=&quot;cname&quot; property=&quot;name&quot;/&gt;
    &lt;!--        映射集合 ofType是集合的泛型--&gt;
    &lt;collection property=&quot;students&quot; ofType=&quot;com.henu.entity.Student&quot;&gt;
        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
        &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;
    &lt;/collection&gt;
&lt;/resultMap&gt;
&lt;select id=&quot;findById&quot; parameterType=&quot;long&quot; resultMap=&quot;classesMap&quot;&gt;
    SELECT c.id as cid, c.name as cname, s.name, s.id FROM student s, classes c WHERE c.id = #{id} and c.id = s.cid
&lt;/select&gt;
</code></pre>
<h4 id="多对多">多对多</h4>
<ul>
<li>创建用户表</li>
</ul>
<pre><code class="language-sql">use springioc;
CREATE TABLE customer(
	id int PRIMARY KEY auto_increment,
	name varchar(11)
)
</code></pre>
<ul>
<li>创建商品表</li>
</ul>
<pre><code class="language-sql">use springioc;
CREATE TABLE goods(
	id int PRIMARY KEY auto_increment,
	name varchar(11)
)
</code></pre>
<ul>
<li>创建中间表</li>
</ul>
<pre><code class="language-sql">use springioc;
CREATE TABLE customer_goods(
	id int PRIMARY KEY auto_increment,
	cid int,
	gid int,
	FOREIGN KEY(cid) REFERENCES customer(id),
	FOREIGN KEY(gid) REFERENCES goods(id)
)
</code></pre>
<ul>
<li>插入数据</li>
</ul>
<pre><code class="language-sql">use springioc;
INSERT INTO customer (name) VALUES(&quot;张三&quot;);
INSERT INTO customer (name) VALUES(&quot;李四&quot;);
INSERT INTO goods (name) VALUES(&quot;华为&quot;);
INSERT INTO goods (name) VALUES(&quot;联想&quot;);
INSERT INTO goods (name) VALUES(&quot;inter&quot;);
INSERT INTO goods (name) VALUES(&quot;Nvidia&quot;);
INSERT INTO customer_goods (cid,gid) VALUES(1,1);
INSERT INTO customer_goods (cid,gid) VALUES(1,2);
INSERT INTO customer_goods (cid,gid) VALUES(1,4);
INSERT INTO customer_goods (cid,gid) VALUES(2,1);
INSERT INTO customer_goods (cid,gid) VALUES(2,3);
</code></pre>
<ul>
<li>SQL语句</li>
</ul>
<pre><code class="language-sql">use springioc;
SELECT c.id, c.name, g.id, g.name FROM customer c, goods g, customer_goods cg WHERE cg.cid =c.id and cg.gid = g.id and c.id = 1
</code></pre>
<pre><code class="language-xml">&lt;resultMap id=&quot;customerMap&quot; type=&quot;com.henu.entity.Customer&quot;&gt;
    &lt;id column=&quot;cid&quot; property=&quot;id&quot;/&gt;
    &lt;result column=&quot;cname&quot; property=&quot;name&quot;/&gt;
    &lt;collection property=&quot;goods&quot; ofType=&quot;com.henu.entity.Goods&quot;&gt;
        &lt;id column=&quot;gid&quot; property=&quot;id&quot;/&gt;
        &lt;id column=&quot;gname&quot; property=&quot;name&quot;/&gt;
    &lt;/collection&gt;
&lt;/resultMap&gt;
&lt;select id=&quot;findById&quot; parameterType=&quot;long&quot; resultMap=&quot;customerMap&quot;&gt;
    SELECT c.id as cid, c.name as cname, g.id as gid, g.name as gname FROM customer c, goods g, customer_goods cg WHERE cg.cid =c.id and cg.gid = g.id and c.id = #{id}
&lt;/select&gt;
</code></pre>
<h3 id="mybatis逆向工程">MyBatis逆向工程</h3>
<p>MyBatis框架需要：实体类，自定义的接口，自定义Mapper.xml。</p>
<p>逆向工程可以帮助开发者自动创建上述三部份组件，提高开发效率。</p>
<h4 id="如何使用">如何使用</h4>
<p>MyBatis Generator，简称 MBG，是⼀个专⻔为 MyBatis 框架开发者定制的代码⽣成器，可⾃动⽣成 MyBatis 框架所需的实体类、Mapper 接⼝、Mapper.xml，⽀持基本的 CRUD 操作，但是⼀些相对复 杂的 SQL 需要开发者⾃⼰来完成。</p>
<ul>
<li>maven坐标</li>
</ul>
<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
        &lt;version&gt;3.4.5&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;8.0.11&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;
        &lt;version&gt;1.3.2&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<ul>
<li>创建 MBG 配置⽂件 generatorConfig.xml</li>
</ul>
<ol>
<li>
<p>jdbcConnection 配置数据库连接信息。</p>
</li>
<li>
<p>javaModelGenerator 配置 JavaBean 的⽣成策略。</p>
</li>
<li>
<p>sqlMapGenerator 配置 SQL 映射⽂件⽣成策略。</p>
</li>
<li>
<p>javaClientGenerator 配置 Mapper 接⼝的⽣成策略。</p>
</li>
<li>
<p>table 配置⽬标数据表（tableName：表名，domainObjectName：JavaBean 类名）。</p>
</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE generatorConfiguration
 PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;
 &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;
&lt;generatorConfiguration&gt;
    &lt;context id=&quot;testTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;
        &lt;jdbcConnection
                        driverClass=&quot;com.mysql.cj.jdbc.Driver&quot;
                        connectionURL=&quot;jdbc:mysql://localhost:3306/springioc?
                                       useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;
                        userId=&quot;root&quot;
                        password=&quot;root&quot;
                        &gt;&lt;/jdbcConnection&gt;
        &lt;javaModelGenerator targetPackage=&quot;com.henu.entity&quot;
                            targetProject=&quot;./src/main/java&quot;&gt;&lt;/javaModelGenerator&gt;
        &lt;sqlMapGenerator targetPackage=&quot;com.henu.repository&quot;
                         targetProject=&quot;./src/main/java&quot;&gt;&lt;/sqlMapGenerator&gt;
        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot;
                             targetPackage=&quot;com.henu.repository&quot; targetProject=&quot;./src/main/java&quot;&gt;
        &lt;/javaClientGenerator&gt;
        &lt;table tableName=&quot;user&quot; domainObjectName=&quot;User&quot;&gt;&lt;/table&gt;
    &lt;/context&gt;
&lt;/generatorConfiguration&gt;
</code></pre>
<ul>
<li>创建 Generator 执⾏类。</li>
</ul>
<pre><code class="language-java">package com.henu.test;
import org.mybatis.generator.api.MyBatisGenerator;
import org.mybatis.generator.config.Configuration;
import org.mybatis.generator.config.xml.ConfigurationParser;
import org.mybatis.generator.exception.InvalidConfigurationException;
import org.mybatis.generator.exception.XMLParserException;
import org.mybatis.generator.internal.DefaultShellCallback;
import java.io.File;
import java.io.IOException;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
public class Main {
    public static void main(String[] args) {
        List&lt;String&gt; warings = new ArrayList&lt;String&gt;();
        boolean overwrite = true;
        String genCig = &quot;/generatorConfig.xml&quot;;
        File configFile = new File(Main.class.getResource(genCig).getFile());
        ConfigurationParser configurationParser = new
            ConfigurationParser(warings);
        Configuration configuration = null;
        try {
            configuration = configurationParser.parseConfiguration(configFile);
        } catch (IOException e) {
            e.printStackTrace();
        } catch (XMLParserException e) {
            e.printStackTrace();
        }
        DefaultShellCallback callback = new DefaultShellCallback(overwrite);
        MyBatisGenerator myBatisGenerator = null;
        try {
            myBatisGenerator = new
                MyBatisGenerator(configuration,callback,warings);
        } catch (InvalidConfigurationException e) {
            e.printStackTrace();
        }
        try {
            myBatisGenerator.generate(null);
        } catch (SQLException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<h3 id="mybatis延迟加载">MyBatis延迟加载</h3>
<ul>
<li>什么是延迟加载？</li>
</ul>
<p>延迟加载也叫懒加载，惰性加载，使用延迟加载可以提高程序的运行效率，针对数据持久层的操作，在某些特定情况下去访问特定的数据库，在其他情况下可以不用访问某些表，从一定程度上减少了Java应用与数据库的交互次数。</p>
<p>查询学⽣和班级的时，学⽣和班级是两张不同的表，如果当前需求只需要获取学⽣的信息，那么查询学 ⽣单表即可，如果需要通过学⽣获取对应的班级信息，则必须查询两张表。</p>
<ul>
<li>配置文件开启延迟加载</li>
</ul>
<pre><code class="language-xml">&lt;settings&gt;
    &lt;!-- 打印SQL--&gt;
    &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot; /&gt;
    &lt;!-- 开启延迟加载 --&gt;
    &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;
&lt;/settings&gt;
</code></pre>
<ul>
<li>将级联查询，拆分为单表查询</li>
</ul>
<p>用<associations>标签里面的<code>select</code>属性指定要调用的方法的全路径名，<code>column</code>属性设定参数该方法结果集的指定参数</p>
<pre><code class="language-xml">ClassesRepository.xml

&lt;select id=&quot;findByIdLazy&quot; parameterType=&quot;long&quot; resultType=&quot;com.henu.entity.Classes&quot;&gt;
    select * from classes where id = #{id}
&lt;/select&gt;

StudentRepository.xml
&lt;resultMap id=&quot;studentMapLazy&quot; type=&quot;com.henu.entity.Student&quot;&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
    &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;
    &lt;association property=&quot;classes&quot; javaType=&quot;com.henu.entity.Classes&quot;
                 select=&quot;com.henu.repository.ClassesRepository.findByIdLazy&quot; column=&quot;cid&quot;&gt;
    &lt;/association&gt;
&lt;/resultMap&gt;
&lt;select id=&quot;findByIdLazy&quot; parameterType=&quot;long&quot; resultMap=&quot;studentMapLazy&quot;&gt;
    select * from student where id = #{id}
&lt;/select&gt;
</code></pre>
<p>开启延迟加载，Mybatis会自动判断需不需要第二次查询，如果仅仅输出student的name，则MyBatis不会查询第二次，若输出的是班级名，则会查询第二次获得班级名</p>
<h3 id="mybatis缓存">MyBatis缓存</h3>
<p>使用缓存，提升程序的运行效率，例如，第一次查询出某个对象，会将其加入缓存中，第二次查询时，只需要从缓存中取出即可，无需再次访问数据库。</p>
<h4 id="缓存分类">缓存分类</h4>
<ul>
<li>一级缓存: SqlSession级别，默认开启，并且不能关闭。</li>
</ul>
<p>操作数据库时需要创建SqlSession对象，在对象中有一个HashMap用于存储缓存数据，不同的SqlSession之间缓存数据区域是互不影响的。</p>
<p>一级缓存的作用域是SqlSession范围的，当同一个SqlSession中执行两次相同的SQL语句时，第一次执行完毕会将结果存入缓存中，第二次查询时，直接从缓存中获取。</p>
<p>需要注意的是，如果SqlSession执行了DML操作(insert ， update，delete)，MyBatis必须将缓存清空，以确保数据的准确性。</p>
<ul>
<li>二级缓存：是Mapper级别缓存，默认关闭，可以开启</li>
</ul>
<p>使用二级缓存时，多个SqlSession使用同一个Mapper的SQL语句操作数据库，得到的数据会存在二级缓存区。使用HashMap存储，相比较于一级缓存，二级缓存的范围更大，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。</p>
<p>二级缓存十多个SqlSession共享的，其作用域是Mapper的同一个namespace，不同的SqlSession两次执行相同的namespace下的SQL语句，参数也相等，则第一次执行成功后会将数据保存在二级缓存中，第二次可以直接从二级缓存中取出数据。</p>
<h4 id="代码验证">代码验证</h4>
<blockquote>
<p>一级缓存</p>
</blockquote>
<pre><code class="language-java">package com.henu.test;

import com.henu.entity.User;
import com.henu.repository.AccountRepository;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import java.io.InputStream;

public class TestForCache {
    public static void main(String[] args) {
        InputStream res = TestForCache.class.getClassLoader().getResourceAsStream(&quot;mybatis.xml&quot;);
        SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();
        SqlSessionFactory factory = builder.build(res);
        SqlSession sqlSession = factory.openSession();
        AccountRepository mapper = sqlSession.getMapper(AccountRepository.class);
        User byId = mapper.findById(1);
        System.out.println(byId);
        //        sqlSession.close();
        //        sqlSession = factory.openSession();
        //        mapper = sqlSession.getMapper(AccountRepository.class);
        User byId2 = mapper.findById(1);
        System.out.println(byId2);

    }
}
</code></pre>
<blockquote>
<p>二级缓存</p>
</blockquote>
<h4 id="mybatis自带的二级缓存">MyBatis自带的二级缓存</h4>
<ul>
<li>在配置文件开启二级缓存</li>
</ul>
<pre><code class="language-xml">&lt;settings&gt;
    &lt;!-- 打印SQL--&gt;
    &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;
    &lt;!-- 开启延迟加载 --&gt;
    &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;
    &lt;!--开启二级缓存--&gt;
    &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;
&lt;/settings&gt;
</code></pre>
<ul>
<li>在对应的Mapper.xml中添加二级缓存的配置</li>
</ul>
<pre><code class="language-xml">&lt;cache/&gt;
</code></pre>
<ul>
<li>实现实体类序列化接口</li>
</ul>
<p><code>Serializable</code></p>
<pre><code class="language-java">package com.henu.entity;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;


@Data
@AllArgsConstructor
@NoArgsConstructor
public class User implements Serializable {
    private long id;
    private String username;
    private String password;
    private int age;
}
</code></pre>
<ul>
<li>Java代码</li>
</ul>
<pre><code class="language-java">package com.henu.test;

import com.henu.entity.User;
import com.henu.repository.AccountRepository;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import java.io.InputStream;

public class TestForCache {
    public static void main(String[] args) {
        InputStream res = TestForCache.class.getClassLoader().getResourceAsStream(&quot;mybatis.xml&quot;);
        SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();
        SqlSessionFactory factory = builder.build(res);
        SqlSession sqlSession = factory.openSession();
        AccountRepository mapper = sqlSession.getMapper(AccountRepository.class);
        User byId = mapper.findById(1);
        System.out.println(byId);
        sqlSession.close();
        sqlSession = factory.openSession();
        mapper = sqlSession.getMapper(AccountRepository.class);
        User byId2 = mapper.findById(1);
        System.out.println(byId2);
    }
}
</code></pre>
<h4 id="第三方缓存ehcache">第三方缓存(ehcache)</h4>
<ul>
<li>添加ehcache依赖</li>
</ul>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt;
    &lt;artifactId&gt;ehcache-core&lt;/artifactId&gt;
    &lt;version&gt;2.4.3&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>添加ehcache配置文件</li>
</ul>
<pre><code class="language-xml">&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot;&gt;
    &lt;diskStore/&gt;
    &lt;defaultCache
                  maxElementsInMemory=&quot;1000&quot;
                  maxElementsOnDisk=&quot;10000000&quot;
                  eternal=&quot;false&quot;
                  overflowToDisk=&quot;false&quot;
                  timeToIdleSeconds=&quot;120&quot;
                  timeToLiveSeconds=&quot;120&quot;
                  diskExpiryThreadIntervalSeconds=&quot;120&quot;
                  memoryStoreEvictionPolicy=&quot;LRU&quot;&gt;
    &lt;/defaultCache&gt;
&lt;/ehcache&gt;
</code></pre>
<ul>
<li>在配置文件中开启二级缓存</li>
<li>在Mapper.xml添加cache标签</li>
</ul>
<pre><code class="language-xml">&lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;&gt;
    &lt;!-- 缓存创建之后，最后⼀次访问缓存的时间⾄缓存失效的时间间隔 --&gt;
    &lt;property name=&quot;timeToIdleSeconds&quot; value=&quot;3600&quot;/&gt;
    &lt;!-- 缓存⾃创建时间起⾄失效的时间间隔 --&gt;
    &lt;property name=&quot;timeToLiveSeconds&quot; value=&quot;3600&quot;/&gt;
    &lt;!-- 缓存回收策略，LRU表示移除近期使⽤最少的对象 --&gt;
    &lt;!-- 回收策略参考计组所学的缓存的移除策略 --&gt;
    &lt;property name=&quot;memoryStoreEvictionPolicy&quot; value=&quot;LRU&quot;/&gt;
&lt;/cache&gt;
</code></pre>
<ul>
<li>不需要实体类实现序列化接口</li>
</ul>
<h3 id="mybatis动态sql">MyBatis动态SQL</h3>
<p>使⽤动态 SQL 可简化代码的开发，减少开发者的⼯作量，程序可以⾃动根据业务参数来决定 SQL 的组 成。</p>
<blockquote>
<p>if 、where  便是与关系and</p>
</blockquote>
<pre><code class="language-xml">&lt;select id=&quot;findByAccount&quot; parameterType=&quot;com.henu.entity.User&quot; resultType=&quot;com.henu.entity.User&quot;&gt;
        select * from mybatis
        &lt;where&gt;
            &lt;if test=&quot;id != 0&quot;&gt;
                and id = #{id}
            &lt;/if&gt;
            &lt;if test=&quot;username != null&quot;&gt;
                and username = #{username}
            &lt;/if&gt;
            &lt;if test=&quot;age != 0&quot;&gt;
                and age = #{age}
            &lt;/if&gt;
            &lt;if test=&quot;password != null&quot;&gt;
                and password = #{password}
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;
</code></pre>
<ul>
<li><code>if</code>标签，当test为true时，会将其包裹的内容加入SQL语句</li>
<li><code>where</code>标签，会自动删除多余的<code>and</code>关键字，通常和<code>if</code>标签一起使用</li>
</ul>
<blockquote>
<p>choose 、when 表示或关系or</p>
</blockquote>
<pre><code class="language-xml">&lt;select id=&quot;findByAccount&quot; parameterType=&quot;com.henu.entity.User&quot; resultType=&quot;com.henu.entity.User&quot;&gt;
    select * from mybatis
    &lt;where&gt;
        &lt;choose&gt;
            &lt;when test=&quot;id!=0&quot;&gt;
                id = #{id}
            &lt;/when&gt;
            &lt;when test=&quot;username!=null&quot;&gt;
                username = #{username}
            &lt;/when&gt;
            &lt;when test=&quot;password!=null&quot;&gt;
                password = #{password}
            &lt;/when&gt;
            &lt;when test=&quot;age!=0&quot;&gt;
                age = #{age}
            &lt;/when&gt;
        &lt;/choose&gt;
    &lt;/where&gt;
&lt;/select&gt;
</code></pre>
<blockquote>
<p>trim</p>
</blockquote>
<p><code>trim</code>标签中的 <code>prefix</code>和 <code>suffix</code> 属性会被⽤于⽣成实际的 SQL 语句，会和标签内部的语句进⾏拼接，如 果语句前后出现了 <code>prefixOverrides</code>或者 <code>suffixOverrides</code>属性中指定的值，MyBatis 框架会⾃动将其删除</p>
<p>模拟where标签：自动删除和where紧邻的and</p>
<pre><code class="language-xml">&lt;select id=&quot;findByAccount&quot; parameterType=&quot;com.henu.entity.Account&quot; resultType=&quot;com.henu.entity.Account&quot;&gt;
    select * from mybatis
    &lt;trim prefix=&quot;where&quot; prefixOverrides=&quot;and&quot;&gt;
        &lt;if test=&quot;id!=0&quot;&gt;
            id = #{id}
        &lt;/if&gt;
        &lt;if test=&quot;username!=null&quot;&gt;
            and username = #{username}
        &lt;/if&gt;
        &lt;if test=&quot;password!=null&quot;&gt;
            and password = #{password}
        &lt;/if&gt;
        &lt;if test=&quot;age!=0&quot;&gt;
            and age = #{age}
        &lt;/if&gt;
    &lt;/trim&gt;
&lt;/select&gt;
</code></pre>
<blockquote>
<p>set 标签</p>
</blockquote>
<p><code>set</code>标签⽤于 <code>update</code>操作，会⾃动根据参数选择⽣成 SQL 语句。只插入不为空的值</p>
<pre><code class="language-xml">&lt;update id=&quot;update&quot; parameterType=&quot;com.henu.entity.User&quot;&gt;
    update mybatis
    &lt;set&gt;
        &lt;if test=&quot;username!=null&quot;&gt;
            username = #{username},
        &lt;/if&gt;
        &lt;if test=&quot;password!=null&quot;&gt;
            password = #{password},
        &lt;/if&gt;
        &lt;if test=&quot;age!=0&quot;&gt;
            age = #{age}
        &lt;/if&gt;
    &lt;/set&gt;
    where id = #{id}
&lt;/update&gt;
</code></pre>
<blockquote>
<p>foreach 标签</p>
</blockquote>
<p><code>foreach</code> 标签可以迭代⽣成⼀系列值，这个标签主要⽤于 SQL 的 in 语句。</p>
<p><code>collection</code>遍历的集合参数</p>
<p><code>open</code> ：集合之前的</p>
<p><code>close</code>：集合之后的</p>
<p><code>item</code>：取出来的值的名字</p>
<p><code>separator</code>：元素之间的分割符</p>
<p><code>foreach</code>：一般不能使用但标签</p>
<pre><code class="language-xml">&lt;select id=&quot;findByIds&quot; parameterType=&quot;com.henu.entity.User&quot; resultType=&quot;com.henu.entity.User&quot;&gt;
    select * from mybatis
    &lt;where&gt;
        &lt;foreach collection=&quot;ids&quot; open=&quot;id in(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt;
            #{id}
        &lt;/foreach&gt;
    &lt;/where&gt;
&lt;/select&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[后端开发基础之Servlet&JSP]]></title>
        <id>https://seulg.github.io/post/hou-duan-kai-fa-ji-chu-zhi-servlet/</id>
        <link href="https://seulg.github.io/post/hou-duan-kai-fa-ji-chu-zhi-servlet/">
        </link>
        <updated>2020-07-05T00:51:18.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="servlet">Servlet</h2>
<h3 id="简介">简介</h3>
<p>servlet是java web开发的基石，是与平台无关的服务器组件，他是运行在servlet容器(tomcat)，负责与客户端通信的组件。</p>
<h3 id="servlet功能">Servlet功能:</h3>
<ol>
<li>创建并返回基于客户端请求的动态HTML页面。</li>
<li>与数据库进行通信</li>
</ol>
]]></summary>
        <content type="html"><![CDATA[<h2 id="servlet">Servlet</h2>
<h3 id="简介">简介</h3>
<p>servlet是java web开发的基石，是与平台无关的服务器组件，他是运行在servlet容器(tomcat)，负责与客户端通信的组件。</p>
<h3 id="servlet功能">Servlet功能:</h3>
<ol>
<li>创建并返回基于客户端请求的动态HTML页面。</li>
<li>与数据库进行通信</li>
</ol>
<!-- more -->
<h3 id="如何使用">如何使用：</h3>
<p>如同简介所说，servlet是一组接口，因此我们想要使用servlet的功能，只需要自定义一个类去继承或者实现改接口即可。那么这个自定义的类就具备了接受客户端请求并作出响应的功能。</p>
<pre><code class="language-java">public class MyServlet implements Servlet {
 @Override
 public void init(ServletConfig servletConfig) throws ServletException {
 }
 @Override
 public ServletConfig getServletConfig() {
 return null;
 }
 @Override
 public void service(ServletRequest servletRequest, ServletResponse
servletResponse) throws ServletException, IOException {
 String id = servletRequest.getParameter(&quot;id&quot;);
 System.out.println(&quot;我是Servlet，我已经接收到了客户端发来的请求，参数是&quot;+id);
 servletResponse.setContentType(&quot;text/html;charset=UTF-8&quot;);
 servletResponse.getWriter().write(&quot;客户端你好，我已接收到你的请求&quot;);
 }
 @Override
 public String getServletInfo() {
 return null;
 }
 @Override
 public void destroy() {
 }
}
</code></pre>
<p>浏览器不能直接访问Servlet文件，只能通过映射的方式来间接访问Servlet</p>
<h3 id="配置映射">配置映射</h3>
<ol>
<li>基于xml文件的配置方式</li>
</ol>
<p>在web.xml文件为每个Servlet文件进行配置</p>
<pre><code class="language-xml">&lt;servlet&gt;
 &lt;servlet-name&gt;myservlet&lt;/servlet-name&gt;
 &lt;servlet-class&gt;com.henu.MyServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
 &lt;servlet-name&gt;myservlet&lt;/servlet-name&gt;
 &lt;url-pattern&gt;/test&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<p>此时启动项目，在地址栏访问/test就可以访问到MyServlet。</p>
<ol start="2">
<li>注解方式配置</li>
</ol>
<p>只需要在实现了Servlet或继承了其子实现类的自定义类上面添加<code>WebServlet</code>注释即可</p>
<pre><code class="language-java">@WebServlet(&quot;/test&quot;)
public class MyServlet implements Servlet {

}
</code></pre>
<p>注解的方式与配置想，xml所实现的效果一致</p>
<h3 id="servlet生命周期">Servlet生命周期</h3>
<p>1、当浏览器访问 Servlet 的时候，Tomcat 会查询当前 Servlet 的实例化对象是否存在，如果不存在， 则通过反射机制动态创建对象，如果存在，直接执⾏第 3 步。</p>
<p>2、调⽤ init ⽅法完成初始化操作。</p>
<p>3、调⽤ service ⽅法完成业务逻辑操作。</p>
<p>4、关闭 Tomcat 时，会调⽤ destory ⽅法，释放当前对象所占⽤的资源。</p>
<p>Servlet 的⽣命周期⽅法：⽆参构造函数、init、service、destory</p>
<p>1、⽆参构造函数只调⽤⼀次，创建对象。</p>
<p>2、init 只调⽤⼀次，初始化对象。</p>
<p>3、service 调⽤ N 次，执⾏业务⽅法。</p>
<p>4、destory 只调⽤⼀次，卸载对象。</p>
<p>####ServletConfig</p>
<p>该接⼝是⽤来描述 Servlet 的基本信息的。</p>
<ol>
<li>getServletName() 返回 Servlet 的名称，全类名(带着包名的类名)</li>
<li>getInitParameter(String key) 获取 init 参数的值（web.xml）</li>
<li>getInitParameterNames() 返回所有的 initParamter 的 name 值，⼀般⽤作遍历初始化参数</li>
<li>getServletContext() 返回 ServletContext 对象，它是 Servlet 的上下⽂，整个 Servlet 的管理者。</li>
<li>ServletConfig 和 ServletContext 的区别：
<ol>
<li>ServletConfig 作⽤于某个 Servlet 实例，每个 Servlet 都有对应的 ServletConfig</li>
<li>ServletContext 作⽤ 于整个 Web 应⽤</li>
<li>⼀个 Web 应⽤对应⼀个 ServletContext，多个 Servlet 实例对应⼀个 ServletContext。</li>
<li>⼀个是局部对象，⼀个是全局对象。</li>
</ol>
</li>
</ol>
<h3 id="servlet层次结构">Servlet层次结构</h3>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2020/07/05/eEGhIOylULMq4WS.png" alt="image-20200705093648581" loading="lazy"></figure>
<p>GenericServlet 实现 Servlet 接⼝，同时为它的⼦类屏蔽了不常⽤的⽅法，⼦类只需要重写 service ⽅ 法即可。 HttpServlet 继承 GenericServlet，根据请求类型进⾏分发处理，GET 进⼊ doGET ⽅法，POST 进⼊ doPOST ⽅法。</p>
<p>我们只需要⾃定义的 Servlet 类只需要继承 HttpServlet 即可，重新实现 doGET 和 doPOST。</p>
<pre><code class="language-java">package com.henu.servlet;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
@WebServlet(&quot;/test&quot;)
public class MyServlet extends HttpServlet {
 @Override
 protected void doGet(HttpServletRequest req, HttpServletResponse resp)
throws ServletException, IOException {
 resp.getWriter().write(&quot;GET&quot;);
 }
 @Override
 protected void doPost(HttpServletRequest req, HttpServletResponse resp)
throws ServletException, IOException {
 resp.getWriter().write(&quot;POST&quot;);
 }
}
</code></pre>
<h2 id="jsp">JSP</h2>
<h3 id="内置对象">内置对象</h3>
<p>1、request：表示⼀次请求，HttpServletRequest。</p>
<p>2、response：表示⼀次响应，HttpServletResponse。</p>
<p>3、pageContext：⻚⾯上下⽂，获取⻚⾯信息，PageContext。</p>
<p>4、session：表示⼀次会话，保存⽤户信息，HttpSession。</p>
<p>5、application：表示当前 Web 应⽤，全局对象，保存所有⽤户共享信息，ServletContext。</p>
<p>6、config：当前 JSP 对应的 Servlet 的 ServletConfig 对象，获取当前 Servlet 的信息。</p>
<p>7、out：向浏览器输出数据，JspWriter。</p>
<p>8、page：当前 JSP 对应的 Servlet 对象，Servlet。</p>
<p>9、exception：表示 JSP ⻚⾯发⽣的异常，Exception。</p>
<p>常⽤的是 request、response、session、application、pageContext</p>
<h3 id="request-常用方法">request 常⽤⽅法</h3>
<p>1、String getParameter(String key) 获取客户端传来的参数。</p>
<p>2、void setAttribute(String key,Object value) 通过键值对的形式保存数据。</p>
<p>3、Object getAttribute(String key) 通过 key 取出 value。</p>
<p>4、RequestDispatcher getRequestDispatcher(String path) 返回⼀个 RequestDispatcher 对象，该对 象的 forward ⽅法⽤于请求转发。</p>
<p>5、String[] getParameterValues() 获取客户端传来的多个同名参数。</p>
<p>6、void setCharacterEncoding(String charset) 指定每个请求的编码。</p>
<h3 id="http-请求状态码">HTTP 请求状态码</h3>
<p>200：正常</p>
<p>404：资源找不到</p>
<p>400：请求类型不匹配</p>
<p>500：Java 程序抛出异常</p>
<h3 id="response-常用方法">response 常⽤⽅法：</h3>
<p>sendRedirect(String path) 重定向，⻚⾯之间的跳转。</p>
<h3 id="转发-getrequestdispatcher-和重定向-sendredirect-的区别">转发 getRequestDispatcher 和重定向 sendRedirect 的区别：</h3>
<p>转发是将同⼀个请求传给下⼀个⻚⾯，重定向是创建⼀个新的请求传给下⼀个⻚⾯，之前的请求结束⽣ 命周期。 转发：同⼀个请求在服务器之间传递，地址栏不变，也叫服务器跳转。 重定向：由客户端发送⼀次新的请求来访问跳转后的⽬标资源，地址栏改变，也叫客户端跳转。 如果两个⻚⾯之间需要通过 request 来传值，则必须使⽤转发，不能使⽤重定向。</p>
<h3 id="jsp-内置对象作用域">JSP 内置对象作⽤域</h3>
<p>4个</p>
<p>page、request、session、application</p>
<p>通过进行设置和取出共享变量：</p>
<p>setAttribute、getAttribute</p>
<p>作⽤域：</p>
<p>page 作用域：对应的内置对象是 pageContext。</p>
<p>request 作⽤域：对应的内置对象是 request。</p>
<p>session 作⽤域：对应的内置对象是 session。</p>
<p>application 作⽤域：对应的内置对象是 application。</p>
<p>作用域的共享范围：</p>
<p>page &lt; request &lt; session &lt; application</p>
<p>page 只在当前⻚⾯有效。</p>
<p>request 在⼀次请求内有效。</p>
<p>session 在⼀次会话内有效。</p>
<p>application 对应整个 WEB 应⽤的。</p>
<ul>
<li>
<p>网站访问量统计</p>
<pre><code class="language-jsp">&lt;%
 Integer count = (Integer) application.getAttribute(&quot;count&quot;);
 if(count == null){
 count = 1;
 application.setAttribute(&quot;count&quot;,count);
 }else{
 count++;
 application.setAttribute(&quot;count&quot;,count);
 }
%&gt;
您是当前的第&lt;%=count%&gt;位访客
</code></pre>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue学习 (未完待续)]]></title>
        <id>https://seulg.github.io/post/vue-xue-xi/</id>
        <link href="https://seulg.github.io/post/vue-xue-xi/">
        </link>
        <updated>2020-06-27T09:04:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="css">CSS</h2>
<h3 id="复合属性">复合属性</h3>
<ul>
<li><code>font</code> : font-style font-weight font-size/line-height font-family;
<ul>
<li>不需要的属性可以省略</li>
<li>必须保留font-size和font-family</li>
<li>顺序不能改变</li>
<li>line-height包括文<code>字高度</code>，<code>上间距</code>，<code>下间距</code>,该属性只改变上下间距</li>
</ul>
</li>
<li><code>background</code>:bcakground-color url(img.jpg) repeat-y fixed pos-x pos-y;
<ul>
<li>background的复合写法，没有顺序约定</li>
<li>背景颜色默认为<code>transparent</code></li>
<li>背景固定默认为<code>scroll</code></li>
<li>背景默认为<code>repeat</code>，可设置为<code>no-repeat</code>取消背景重复</li>
<li>背景色半透明<code>background: rgba(0,0,0,0.3)</code>,设置alpha通道，可省略0，直接.3</li>
</ul>
</li>
<li><code>border</code>:border-width border-style border-color
<ul>
<li>定义元素的边框的粗细，样式，颜色</li>
<li>没有顺序规定</li>
<li>可以单独修改某个边框，例如：<code>border-top border-left</code></li>
<li>使用<code>border-collapse: collapse</code>合并相邻边框</li>
</ul>
</li>
<li><code>padding</code>设置内边距
<ul>
<li>1个值，代表上下左右都是这个值</li>
<li>2个值，代表上下，左右</li>
<li>三个值，代表，上，左右，下</li>
<li>四个值，代表上，右，下，左(顺时针)</li>
<li>设置padding后，内容和盒子就有了距离，并且会改变盒子大小</li>
<li><strong>在盒子里的块元素，不设置长宽，就默认不会撑破盒子</strong></li>
</ul>
</li>
<li><code>margin</code>设置盒子外边距
<ul>
<li>使用方式与<code>padding</code>相同</li>
<li>水平居中(盒子设置了宽度)，将盒子左右外边距设置为<code>auto</code>即可</li>
<li>让行内元素或行内块元素居中，只需要给其父元素添加<code>text-align: center</code></li>
</ul>
</li>
<li><code>box-shadow</code>: h-shadow v-shadow blur spread color inset
<ul>
<li>一般省略inset，默认为outset，但是不能显式指定为outset</li>
<li>blur为模糊距离，spread为阴影尺寸，color为颜色，这些都是可选属性</li>
</ul>
</li>
<li><code>text-shadow</code>: h-shadow v-shadow blur color
<ul>
<li>基本与盒子阴影用法一致</li>
</ul>
</li>
</ul>
<h3 id="常用单位">常用单位</h3>
<ul>
<li>px （绝对单位）
<ul>
<li>1px就是一个点</li>
<li>在调整font-size时用px单位，通常要设置line-height（避免行距过大或过小）</li>
</ul>
</li>
<li>em （相对单位）
<ul>
<li>相当于大小，永远是其上一层次的倍数</li>
<li>有累乘特性。（例如 <div height=10px><div height=2em><div height = 2em></div></div></div>,最内侧div height为10x2x2=40px）</li>
<li>通常一起设置为 font-size 和 line-height 实现 字体大小和行距按比例缩放</li>
</ul>
</li>
<li>rem （相对单位）
<ul>
<li>作用同上em，只不过是相对于html的倍数</li>
<li>由此即可去除累乘特性</li>
</ul>
</li>
<li>vw（viewport width），vh（viewport height）
<ul>
<li>是我们看到的一个页面的宽度，高度大小的百分比倍</li>
<li>值只能再1-100</li>
<li>50vw就是半个可是界面的宽度</li>
</ul>
</li>
<li>vmin,vmax
<ul>
<li>vmin为屏幕较短一边，vmax为较长一边</li>
<li>为了适配移动设备和旋转设备</li>
<li>常用于响应式布局</li>
</ul>
</li>
</ul>
<h3 id="选择器">选择器</h3>
<ul>
<li>
<p>基础选择器</p>
<ul>
<li>标签选择器</li>
<li>id选择器</li>
<li>类名选择器</li>
</ul>
</li>
<li>
<p>复合选择器</p>
<ul>
<li>
<p>后代选择器</p>
<ul>
<li>基础选择器 + 空格 + 基础选择器</li>
<li>不会选择到空格前面的基础选择器选择的元素</li>
</ul>
</li>
<li>
<p>子代选择器</p>
<ul>
<li>基础选择器 + &gt; + 基础选择器</li>
</ul>
</li>
<li>
<p>并集选择器</p>
<ul>
<li>基础选择器 + , + 基础选择器</li>
</ul>
</li>
<li>
<p>加号选择器</p>
<ul>
<li>基础选择器 + <code>+</code> + 基础选择器</li>
<li>会选则+前的选择器同一级的，紧跟着他的 符合+好后选择器选择的内容的元素</li>
<li>若没有紧挨的匹配项则不会选择到任何东西（即有其他元素相隔就匹配不到任何元素）</li>
</ul>
</li>
<li>
<p>~选择器</p>
<ul>
<li>类似+选择器，是不过是同一层后面所有的适配元素</li>
<li>即使有其他元素相隔，也会选择到</li>
</ul>
</li>
<li>
<p><code>*</code>选择器</p>
<ul>
<li>选择所有元素，通常用于清除默认值</li>
</ul>
</li>
<li>
<p>可以与上述选择器混合使用</p>
</li>
<li>
<p>属性选择器</p>
<ul>
<li>tag[属性]会选择带有此属性tag元素</li>
<li>支持搜索功能
<ul>
<li>用a[href^=https://”]可以选择href<strong>开头</strong>为https://的所有a标签</li>
<li>用a[href$=https://”]可以选择href<strong>结尾</strong>为https://的所有a标签</li>
<li>用a[href*=https”]可以选择href中含有https这个关键词的所有a标签</li>
</ul>
</li>
</ul>
</li>
<li>
<p>伪类选择器</p>
<ul>
<li>
<p>适用于任何元素的伪类选择器</p>
<ul>
<li>a:link 选择所有没被选择过的链接</li>
<li>a:visited 选择已经被选择过的链接</li>
<li>a:hover 选择鼠标指针位于其上的链接</li>
<li>a:active 选择活动链接</li>
<li>安装LVHA的顺序写以确保css生效</li>
</ul>
</li>
<li>
<p><strong>:nth-child(index)选择器 不仅仅使用于a标签</strong></p>
<ul>
<li>必须于其他选择器结合，选择一组元素中的特定元素</li>
<li>index=even时为选择偶数位置的元素</li>
<li>3n+0 选择在3倍数位置的元素</li>
</ul>
</li>
<li>
<p>:foucs（适用于input元素）</p>
<ul>
<li>选择有焦点的表单元素</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/14333787-0ae823b149ed21f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/748/format/webp" alt="伪类" loading="lazy"></figure>
</li>
</ul>
<h3 id="css三大特性">CSS三大特性</h3>
<h4 id="层叠性">层叠性</h4>
<p><strong>必须是相同的选择器设置相同的属性才会产生冲突</strong></p>
<p>样式冲突的解决方式是就近原则，哪个样式离得近，使用哪个样式。只会覆盖冲突的属性，不会覆盖其他的属性。</p>
<p>选择器不同，则考虑其优先级</p>
<h4 id="继承性">继承性</h4>
<p>字标签会继承父标签的某些属性</p>
<p>参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/inheritance">MDN</a></p>
<p>行高的继承，行高可以跟单位，也可以不跟单位，不跟单位时，就是当前元素文字大小的em。</p>
<h4 id="优先级">优先级</h4>
<p>优先级参考<a href="https://www.runoob.com/w3cnote/css-style-priority.html">菜鸟教程</a></p>
<h3 id="盒子模型">盒子模型</h3>
<figure data-type="image" tabindex="2"><img src="https://www.runoob.com/images/box-model.gif" alt="CSS box-model" loading="lazy"></figure>
<h3 id="清除浮动">清除浮动</h3>
<p>当有些父盒子，不方便指定高度，而其内部的子元素是浮动的，则该父盒子就会没有高度。因为浮动是不占用空间的。为了解决浮动给父元素带来的影响，就需要清除浮动。</p>
<p>清除浮动的方式：</p>
<ol>
<li>
<p>额外标签法</p>
<ol>
<li>在最后一个浮动元素后面添加一个<strong>空的块级元素</strong>(br)</li>
<li>给这个标签添加<code>clear: both</code>属性即可</li>
<li>优点：通俗易懂，书写方便    缺点：添加了无意义的标签，结构比较差</li>
</ol>
</li>
<li>
<p>父级元素添加<code>overflow</code>属性</p>
<ol>
<li>给其父元素(包裹浮动元素的元素)添加<code>overflow</code>属性，值可以为<code>hidden</code>或<code>scroll</code>或<code>auto</code></li>
<li>优点：代码简介  缺点：无法显示溢出部分</li>
</ol>
</li>
<li>
<p>父级元素添加<code>::after</code>为元素</p>
<ol>
<li>
<p>给父元素添加<code>::after</code></p>
</li>
<li>
<p>伪元素必须有<code>content</code>属性，并且把他转换为块元素</p>
</li>
<li>
<p>设置<code>clear: both</code>属性，清除浮动</p>
<pre><code class="language-css">.box::after {
    content: &quot;&quot;;
    display: block;
    height: 0;
    clear: both;
    visibility: hidden;
}
</code></pre>
</li>
</ol>
</li>
<li>
<p>父级元素添加双伪元素</p>
<ol>
<li>
<p>在添加<code>::after</code>伪元素的基础上</p>
</li>
<li>
<p>添加<code>::befor</code>伪元素</p>
<pre><code class="language-css">.box::befor , .box::after {
    content: &quot;&quot;;
    display : table;
}
.box::after {
    clear: both;
}
</code></pre>
</li>
</ol>
</li>
</ol>
<h3 id="css属性书写顺序">CSS属性书写顺序</h3>
<ol>
<li>布局定位属性:<code>display/position/float/clear/visibility/overflow</code></li>
<li>自身属性:<code>width/height/margin/padding/border/background</code></li>
<li>文本属性:<code>color/font/text-decoration/text-align/white-space/break-word</code></li>
<li>其他属性:<code>content/cursor/border-radius/box-shadow/background:linear-gradient</code></li>
</ol>
<h3 id="定位position">定位position</h3>
<ol>
<li>
<p>定位模式</p>
<ol>
<li><code>static</code>静态定位
<ol>
<li>元素默认的定位方式，也就是无定位</li>
<li>按照标准流的特性摆放位置</li>
</ol>
</li>
<li><code>relative</code>相对定位
<ol>
<li>相对于其原位置偏移</li>
<li><strong>不会脱离标准流</strong>，会继续占有其原来的位置</li>
<li>最典型的应用就是作为绝对定位的父盒子</li>
</ol>
</li>
<li><code>absolute</code>绝对定位
<ol>
<li>相对与其祖先元素定位</li>
<li>绝对定位不再占有原来的位置，<strong>脱离了标准流</strong></li>
<li>如果没有显示的父元素并且其父元素要有定位属性(静态定位除外)，其父元素为html</li>
<li>如果其父元素无定位，父元素的父元素有定位，则相对于距离其最近的有定位的祖先元素进行边偏移</li>
<li>最典型的就是子绝父相</li>
</ol>
</li>
<li><code>fixed</code>固定定位
<ol>
<li>以浏览器的可视窗口为参考定位</li>
<li>为了让其靠着版心固定
<ol>
<li><code>left</code>或者<code>right</code>设置为50%</li>
<li><code>margin</code>减去或加上版心宽度的一半</li>
<li>用<code>margin</code>调整与版心的间距</li>
</ol>
</li>
<li>不占有原先位置<strong>脱离标准流</strong></li>
</ol>
</li>
<li><code>stick</code>粘性定位
<ol>
<li>以浏览器可视窗口为参照</li>
<li>占有原先的位置，<strong>没有脱离标准流</strong></li>
<li>必须设置一个边偏移才会生效</li>
</ol>
</li>
</ol>
</li>
<li>
<p>边偏移</p>
<ol>
<li><code>top</code>，定义元素相对于其父元素的上边线距离</li>
<li><code>bottom</code>，定义元素相对于其父元素的下边线距离</li>
<li><code>left</code>，定义元素相对于其父元素的左边线距离</li>
<li><code>right</code>，定义元素相对于其父元素的右边线距离</li>
<li>只有存在定位模式，边偏移才会生效</li>
</ol>
</li>
<li>
<p>定位叠放顺序</p>
<ol>
<li><code>z-index</code>: 数值，默认auto</li>
<li>数值可以是正整数，负整数和0，数值越大，盒子越先显示</li>
</ol>
</li>
<li>
<p>定位拓展</p>
<ol>
<li>居中绝对定位的盒子
<ol>
<li><code>left</code>: 50%</li>
<li><code>margin-left</code>: -width/2px</li>
</ol>
</li>
<li>绝对定位的盒子
<ol>
<li>设置<code>margin: auto</code>是失效的</li>
</ol>
</li>
<li>定位特殊特性
<ol>
<li>给行内元素添加绝对定位或者固定定位，
<ol>
<li>就可以给该元素设置宽和高</li>
</ol>
</li>
<li>块元素添加了绝对定位或者固定定位，
<ol>
<li>默认宽度或高度是其内容的大小</li>
<li>可以给改元素设置长和宽</li>
<li>没有添加的时候，默认是占一行</li>
<li>脱离标准流的盒子不会触发外边距塌陷</li>
</ol>
</li>
</ol>
</li>
<li>脱标与浮动
<ol>
<li>脱标元素会完全失去原本的位置，会压住其下面的盒子及内容</li>
<li>浮动只会压住下面标准流的盒子，不会压住下面标准流盒子里面的文字(图片)</li>
<li>浮动最初产生的目的就是做文字环绕效果</li>
</ol>
</li>
</ol>
<h3 id="隐藏元素">隐藏元素</h3>
<ol>
<li><code>display</code>
<ol>
<li>none
<ol>
<li>隐藏对象</li>
<li>不再占有原来的位置</li>
</ol>
</li>
<li>block
<ol>
<li>显示对象</li>
</ol>
</li>
</ol>
</li>
<li><code>visibility</code>
<ol>
<li>inherit:继承父对象的可见性</li>
<li>visible，显示元素</li>
<li>hidden，隐藏元素</li>
<li>collapse，用来隐藏表格的行或列</li>
<li>会继续占有原来的位置</li>
</ol>
</li>
<li><code>overflow</code>
<ol>
<li>visible，显示溢出部分</li>
<li>hidden，只隐藏溢出部分</li>
<li>scroll，设置一个滚动条</li>
<li>auto，会在需要的时候设置一个滚动条</li>
<li>只显示或隐藏溢出的部分</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="css技巧">CSS技巧</h3>
<ol>
<li>
<p>css小三角的做法</p>
<pre><code class="language-css">.box {
    width: 0;
    height: 0;
    border-top: 10px solid red;
}
/*默认没有大小的盒子，的每个边框就是一个三角*/
</code></pre>
</li>
<li>
<p>行内块和文字垂直居中</p>
</li>
</ol>
<pre><code class="language-css">.image {
    vertical-align: middle;
}

/*让图片和文字垂直居中对齐*/
</code></pre>
<ol start="3">
<li>图片下面的缝隙</li>
</ol>
<pre><code class="language-css">/*可以将图片转换为块元可以将图片转换为块元素*/
.image {
    display: block;
}
/*将图片改为默认非基线对齐*/
.image {
    vertical-align: bottom;
}
</code></pre>
<p>​	4.	单行文本溢出隐藏</p>
<pre><code class="language-css">.p {
    /*禁止文字换行，normal为默认值*/
    white-space: nowarp;
    /*溢出隐藏*/
    overflow: hidden;
    /*文字溢出部分用...代替*/
    textoverflow: ellipsos;
}
</code></pre>
<p>5.margin负值妙用</p>
<pre><code class="language-css">/*盒子浮动后要加边框，取消1+1=2的边框*/
ul li {
    float: left;
    border: 1px solid red;
    margin-left: -1px;
}
/*盒子是先浮动，后margin，
 *第一个盒子浮动后，左移一个px，
 *第二个盒子浮动后，会紧挨着第一个盒子*/
</code></pre>
<pre><code class="language-css">/*实现鼠标经过显示边框*/
/*只需要给相应的盒子添加相对定位或者改变z-index*/
ul li:hover {
    position:relative;
    border: 1px solid blue;
}
/*在其他盒子都有定位的情况下可以这只z-index*/
ul li:hover {
    border: 1px solid blue;
    z-index: 5;
}
</code></pre>
<ol start="6">
<li>
<p>行内块元素的居中</p>
<p>只要给其父盒子添加<code>text-align: center</code>属性即可</p>
<p>可以把一些元素转换为行内块元素，快捷居中</p>
</li>
<li>
<p>css直角三角形</p>
<p>参照1,只保留两个边框就行了，用边框的宽度调整三角形形状</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Win10部署spark开发环境]]></title>
        <id>https://seulg.github.io/post/win10-bu-shu-spark-kai-fa-huan-jing/</id>
        <link href="https://seulg.github.io/post/win10-bu-shu-spark-kai-fa-huan-jing/">
        </link>
        <updated>2020-06-06T15:31:13.000Z</updated>
        <summary type="html"><![CDATA[<p>通过本文，你将了解到：</p>
<ul>
<li>win上安装包管理神器<code>scoop</code>（附带科学上网）</li>
<li>安装<code>scala</code> <code>maven</code></li>
<li>启用wsl2，安装Arch子系统</li>
<li>解决wsl2虚拟机ip问题</li>
<li>美化Terminal</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<p>通过本文，你将了解到：</p>
<ul>
<li>win上安装包管理神器<code>scoop</code>（附带科学上网）</li>
<li>安装<code>scala</code> <code>maven</code></li>
<li>启用wsl2，安装Arch子系统</li>
<li>解决wsl2虚拟机ip问题</li>
<li>美化Terminal</li>
</ul>
<!-- more -->
<h3 id="scoop">Scoop</h3>
<h4 id="简介">简介：</h4>
<p>​		对于scoop你可能比较陌生，但是对于包管理器你应该已经了解了相关知识（apt yum pacman 等等）。而在包管理器往往用于linux上，用来管理软件，scoop就是一款在win上的包管理器，它可以解决大多数程序员较为苦恼的开发环境的部署问题。（主要是他能帮我们安装软件的时候自动设置环境变量）。详情见<a href="https://scoop.sh/">官网</a>。</p>
<h4 id="安装前准备"><a href="https://www.jianshu.com/p/50993df76b1c">安装前准备</a></h4>
<ul>
<li>用户名不含中文字符</li>
<li>Windows 7 SP1+ / Windows Server 2008+</li>
<li>计算机能够科学上网</li>
<li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.microsoft.com%2Fen-us%2Fdownload%2Fdetails.aspx%3Fid%3D34595">PowerShell 3+</a></li>
<li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.microsoft.com%2Fnet%2Fdownload">.NET Framework 4.5+</a></li>
</ul>
<p><strong>若Powershell或.NET Franmework版本过旧，更新后重启即可。<br>
若不清楚版本号，可<code>Win+R</code>运行powershell，输入以下命令获取版本号。</strong></p>
<pre><code class="language-powershell">$PSVersionTable.PSVersion.Major   #查看Powershell版本
$PSVersionTable.CLRVersion.Major  #查看.NET Framework版本
</code></pre>
<h4 id="科学上网v2ray请自备vemss链接">科学上网（v2ray,请自备<a href="https://railgun.best/">vemss</a>链接）</h4>
<h5 id="下载图形化界面qv2ray">下载图形化界面<a href="https://github.com/Qv2ray/Qv2ray/releases">qv2ray</a></h5>
<p>点击链接，下载最新版本（对应自己系统的位数x64或着x32），安装到本地磁盘</p>
<h5 id="下载v2ray核心">下载<a href="https://github.com/v2ray/v2ray-core/releases">v2ray核心</a></h5>
<p>同样选择对应版本，在<code>C:/Users/xstar/AppData/Local/qv2ray</code>目录下新建vcore文件夹，将下载的v2ray压缩包的内容解压到该文件夹下</p>
<p><strong>xstar为你的用户名</strong></p>
<p>目录结构如下</p>
<figure data-type="image" tabindex="1"><img src="https://s1.ax1x.com/2020/06/08/tWFDH0.png" alt="tWFDH0.png" loading="lazy"></figure>
<h5 id="入站设置">入站设置</h5>
<p>依次打开首选项-&gt;入站设置，监听地址不用动（默认127.0.0.1）</p>
<ul>
<li>建议scoket为1080端口</li>
<li>http为2333端口</li>
</ul>
<h5 id="导入你的vmess链接">导入你的vmess链接</h5>
<figure data-type="image" tabindex="2"><img src="https://s1.ax1x.com/2020/06/08/tWFhuR.png" alt="tWFhuR.png" loading="lazy"></figure>
<h5 id="或者导入vmess订阅">或者导入vmess订阅</h5>
<figure data-type="image" tabindex="3"><img src="https://s1.ax1x.com/2020/06/08/tWknaV.png" alt="tWknaV.png" loading="lazy"></figure>
<h5 id="启动系统代理">启动系统代理</h5>
<p>开启代理，便可以进行科学上网，有关如何配合浏览器插件做到浏览器热切换代理，请在本站找Manjaro的有关内容</p>
<h4 id="安装scoop">安装scoop</h4>
<p><strong>tips:</strong></p>
<ul>
<li>scoop软件都是从git仓库clone下来的，因此需要科学上网</li>
<li>scoop安装的软件默认在<code>C:\Users\xstar\scoop\apps</code>下xstar为你的用户名</li>
<li>scoop 可以用-g参数为全局安装<code>C:\ProgramData\scoop\apps\</code></li>
<li>scoop只会保留最新版的软件，因此对于scala2.11.12不能用scoop安装</li>
</ul>
<h5 id="打开powershell分别执行以下两条命令">打开<code>powershell</code>分别执行以下两条命令</h5>
<pre><code class="language-powershell">Set-ExecutionPolicy RemoteSigned -scope CurrentUser
iwr -useb get.scoop.sh | iex
</code></pre>
<h5 id="scoop-帮助文档">scoop 帮助文档</h5>
<pre><code class="language-powershell">Usage: scoop &lt;command&gt; [&lt;args&gt;]

Some useful commands are:

alias       Manage scoop aliases
bucket      Manage Scoop buckets
cache       Show or clear the download cache
checkup     Check for potential problems
cleanup     Cleanup apps by removing old versions
config      Get or set configuration values
create      Create a custom app manifest
depends     List dependencies for an app
export      Exports (an importable) list of installed apps
help        Show help for a command
home        Opens the app homepage
info        Display information about an app
install     Install apps
list        List installed apps
prefix      Returns the path to the specified app
reset       Reset an app to resolve conflicts
search      Search available apps
status      Show status and check for new app versions
uninstall   Uninstall an app
update      Update apps, or Scoop itself
virustotal  Look for app's hash on virustotal.com
which       Locate a shim/executable (similar to 'which' on Linux)

Type 'scoop help &lt;command&gt;' to get help for a specific command.
</code></pre>
<h5 id="用scoop安装git-busybox-sudo">用scoop安装git busybox sudo</h5>
<pre><code class="language-powershell">scoop config proxy 127.0.0.1:1080	#为scoop设置代理
scoop install git		#众所周知，强大的版本控制工具
scoop install busybox	#让你在win上使用linux的部分命令，包括netcat（nc）
scoop install sudo		#类似linux的提权，以管理员身份运行命令
</code></pre>
<h5 id="为scoop添加extras仓库">为scoop添加extras仓库</h5>
<pre><code class="language-powershell">scoop bucket add extras
</code></pre>
<h3 id="安装maven-scala">安装maven scala</h3>
<p>​	什么？有了scoop你还在为安装maven发愁么？一条命令轻松搞定<code>scoop install maven</code>,下面讲一下maven换源，以及IDEA整合maven。</p>
<h4 id="maven设置">maven设置</h4>
<p>用你的编辑器（记事本）打开<code>C:\Users\xstar\scoop\apps\maven\3.6.3\conf\settings</code></p>
<ul>
<li>
<p>设置本地仓库位置，这里建议保存到C盘之外，</p>
<ul>
<li>直接添加<localRepository>E:\Java\MavenRepository</localRepository></li>
</ul>
</li>
<li>
<p>换阿里云的源</p>
<ul>
<li>找到mirrors标签，将以下内容复制进该标签内</li>
</ul>
<pre><code class="language-xml">     &lt;mirror&gt;
        &lt;id&gt;aliyunmaven&lt;/id&gt;
        &lt;name&gt;aliyun maven&lt;/name&gt;
        &lt;url&gt;https://maven.aliyun.com/repository/public &lt;/url&gt;
        &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;
    &lt;/mirror&gt;
</code></pre>
</li>
</ul>
<h4 id="idea整合maven">IDEA整合maven</h4>
<p>打开idea，一次打开以下选项卡</p>
<p><code>File-&gt;New Projects Settings-&gt;Setting for New Projects-&gt;Maven</code></p>
<ul>
<li>
<p><code>Maven home directory</code>路径改为<code>C:/Users/xstar/scoop/apps/maven/3.6.3</code>(xstar为你的用户名)</p>
</li>
<li>
<p><code>USer setting file</code>路径改为<code>C:\Users\xstar\scoop\apps\maven\3.6.3\conf\settings.xml</code>，并勾选<code>override</code></p>
</li>
<li>
<p>此时,Local repository应该已经为你设置的本地仓库路径，勾选<code>override</code></p>
</li>
</ul>
<p>至此，你新建maven项目，便会默认使用你本机安装的maven，而不是idea自带的maven环境</p>
<h4 id="安装scala">安装scala</h4>
<p>此处比较简单，直接下载scala对应版本的msi安装文件，无脑安装即可</p>
<p><code>scala 2.11.12</code>版本的<a href="https://downloads.lightbend.com/scala/2.11.12/scala-2.11.12.msi">下载链接</a></p>
<h4 id="idea整合scala">IDEA整合scala</h4>
<ul>
<li>在IDEA安装插件scala</li>
<li>在你新建的maven项目的pom.xml中添加以下内容</li>
</ul>
<pre><code class="language-xml">    &lt;build&gt;
        &lt;finalName&gt;WordCount&lt;/finalName&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;net.alchim31.maven&lt;/groupId&gt;
                &lt;artifactId&gt;scala-maven-plugin&lt;/artifactId&gt;
                &lt;version&gt;3.3.2&lt;/version&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;compile&lt;/goal&gt;
                            &lt;goal&gt;testCompile&lt;/goal&gt;
                        &lt;/goals&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
</code></pre>
<ul>
<li>如果你要编写spark的内容，请完成下一步内容</li>
</ul>
<h4 id="配置winutils">配置winutils</h4>
<p><strong>tips:</strong></p>
<p>winutils，是支持在win上跑hadoop的一些静态库，并不是完整的hadoop环境,spark也需要此环境</p>
<ul>
<li>你可以选择用scoop安装此环境</li>
</ul>
<pre><code class="language-powershell">scoop install hadoop-winutils	#版本较低2.8.1,也就是说如果你要在win上安装hadoop，也只能安装2.8.1版本的hadoop
</code></pre>
<ul>
<li>你可以选择较高版本的winutils手动安装
<ul>
<li>下载[<a href="https://github.com/s911415/apache-hadoop-3.1.0-winutils">apache-hadoop-3.1.0-winutils</a>],将此压缩包解压到本地磁盘</li>
<li>添加环境变量直接在，请百度如何添加环境变量，基操不讲</li>
</ul>
</li>
<li>关于要安装hadoop的说明，如果你要在win上安装完整的hadoop环境，在你解压缩玩hadoop后，请用对应版本的winutils覆盖hadoop安装路径下的bin目录</li>
</ul>
<h3 id="启用wsl2安装arch子系统">启用wsl2,安装Arch子系统</h3>
<h4 id="前提条件">前提条件</h4>
<ul>
<li>win10版本必须2004 的内部版本 19041 及以上
<ul>
<li><code>win+r</code>输入<code>winver</code>查看你的版本号</li>
<li>若版本号过低，请先升级您的系统</li>
</ul>
</li>
<li>已经打开wsl服务
<ul>
<li>打开控制面板</li>
<li>选择卸载程序</li>
<li>点击左侧的<code>启用或关闭windows功能</code></li>
<li>找到<code>适用于windows的linux子系统</code>打勾起启用即可</li>
</ul>
</li>
</ul>
<h4 id="设置默认启用wsl2">设置默认启用wsl2</h4>
<p><strong>没有特殊说明以下步骤都是管理员身份运行powershell</strong></p>
<ul>
<li>启用虚拟机平台</li>
</ul>
<pre><code class="language-powershell">dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart
</code></pre>
<ul>
<li>将wsl2设为默认版本</li>
</ul>
<pre><code class="language-powershell">wsl --set-default-version 2
</code></pre>
<ul>
<li>如果你的电脑有使用wsl1的子系统，需要手动为其升级wsl2，若没有请跳过此步骤</li>
</ul>
<pre><code class="language-powershell">#1.查看已安装的子系统
wsl --list --verbose
#为其升级
wsl --set-version &lt;distribution name&gt; &lt;versionNumber&gt;
#distribution name 为你的子系统的名字，第一部中会显示
#versionNumber写2即可
</code></pre>
<h4 id="安装arch或者其他版本的子系统">安装Arch或者其他版本的子系统</h4>
<h5 id="其他版本">其他版本</h5>
<p>打开win10应用商店，搜索wsl2，安装你想用的即可，比较简单</p>
<h5 id="arch">Arch</h5>
<p>我Arch邪教，win10商店没有，但是github上有<a href="https://github.com/yuk7/ArchWSL">开源项目</a>，完美支持wsl2</p>
<h6 id="安装步骤">安装步骤</h6>
<ul>
<li>下载<a href="https://github.com/yuk7/ArchWSL/releases">release</a>的<a href="https://github.com/yuk7/ArchWSL/releases/download/20.4.3.0/Arch.zip">Arch.zip</a>,<a href="https://github.com/yuk7/ArchWSL/releases/download/20.4.3.0/ArchWSL-AppX_20.4.3.0_x64.appx">ArchWSL-AppX_20.4.3.0_x64.appx</a>,<a href="https://github.com/yuk7/ArchWSL/releases/download/20.4.3.0/ArchWSL-AppX_20.4.3.0_x64.cer">ArchWSL-AppX_20.4.3.0_x64.cer</a></li>
<li>将压缩包解压至那你要安装的目录</li>
<li>双击安装cer证书</li>
<li>安装Archappx</li>
<li>然后你就可以启动你的子系统了</li>
</ul>
<h6 id="配置">配置</h6>
<ul>
<li>
<p>终端输入Arch.exe，修改root密码 passwd</p>
</li>
<li>
<p>进入Arch后输入<code>EDITOR=vim visudo</code></p>
<ul>
<li>按<code>/%wheel ALL=(ALL) ALL</code>（/是vim里面的搜索模式）</li>
<li>去掉该行注释即可</li>
</ul>
</li>
<li>
<p>添加普通用户</p>
<ul>
<li>
<pre><code class="language-powershell"> # 添加用户
useradd -m -G wheel -s /bin/bash {username}
# 修改密码
passwd {username}

</code></pre>
</li>
</ul>
</li>
<li>
<p>退出子系统<code>输入exit</code>即可</p>
</li>
<li>
<p>设置默认登录用户为普通用户</p>
</li>
<li>
<p>在powershell中输入<code>Arch.exe config --default-user {username}</code></p>
</li>
<li>
<p>此后你可以在你的powershell中键入bash 快速进入子系统（前提只安装了一个子系统）</p>
</li>
<li>
<p>初始化密钥圈</p>
<ul>
<li>
<pre><code>&gt;bash
[user@PC-NAME]$ sudo pacman-key --init
[root@PC-NAME]$ sudo pacman-key --populate
</code></pre>
</li>
</ul>
</li>
<li>
<p>换源</p>
<ul>
<li><code>sudo vim /etc/pacman.conf</code></li>
<li>将以下内容添加至末尾</li>
<li><code>shell [archlinuxcn] Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch</code></li>
<li>安装密钥并立即更新系统<code>sudo pacman -Sy archlinuxcn-keyring &amp;&amp; sudo pacman -Syyu</code></li>
</ul>
</li>
<li>
<p>安装yay <code>sudo pacman -S yay</code></p>
</li>
<li>
<p>解决D-Bus</p>
<ul>
<li>
<pre><code>sudo mkdir /run/dbus -p
sudo dbus-daemon --system
</code></pre>
</li>
</ul>
</li>
<li>
<p>systemd</p>
<ul>
<li>下载 <a href="https://github.com/yuk7/arch-systemctl-alt/releases/download/1.4.4181-1/systemd-altctl-1.4.4181-1-any.pkg.tar.xz">systemd-altctl-1.4.4181-1-any.pkg.tar.xz</a></li>
<li>进入该文件目录<code>sudo pacman -U systemd-altctl-1.4.4181-1-any.pkg.tar.xz</code></li>
</ul>
</li>
<li>
<p>安装<a href="https://aur.archlinux.org/packages/genie-systemd">genie-systemd</a></p>
<ul>
<li><code>yay -S genie-systemd</code></li>
<li>将<code>genie -s &amp;</code>添加至~/.bashrc</li>
</ul>
</li>
</ul>
<h3 id="解决wsl2虚拟机ip问题">解决wsl2虚拟机ip问题</h3>
<h4 id="问题由来">问题由来</h4>
<p>​	wsl2相当于一个虚拟机，每次启动都会为子系统分配一个ip，但是这个ip不是固定的，导致了如果你在子系统部署docker需要经常查看其ip，很不方便。当然如果你需要在局域网内访问wsl2，则需要win端口转发。</p>
<p>​	目前比较好的解决方案就是<a href="https://link.zhihu.com/?target=https%3A//github.com/shayne/go-wsl2-host/">go-wsl2-host</a>,这个项目，可以在你每次启动wsl2时，自动把wsl2的ip写入宿主机的hosts，这就保证了每次都可以用同一个hostname访问wsl2</p>
<h4 id="下载wsl2hostexe">下载<a href="https://github.com/shayne/go-wsl2-host/releases/download/v0.3.4/wsl2host.exe">wsl2host.exe</a></h4>
<p>建议将其放入C盘,以避免误删</p>
<ul>
<li>以管理员身份打开cmd，或者powershell，进入<code>wsl2host.exe</code>目录
<ul>
<li>如果你安装了sudo，那么直接打开cmd或powershell，用sudo提权即可</li>
</ul>
</li>
<li>执行<code>.\wsl2host.exe install</code>
<ul>
<li>Windows Username: <username-you-use-to-login-to-windows>
<ul>
<li>你的win账户名</li>
</ul>
</li>
<li>Windows Password: <password-for-this-user>
<ul>
<li>该账户的密码，<strong>注意不是PIN，是密码！</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="添加启动服务权限">添加启动服务权限</h4>
<ul>
<li>
<p>windows管理工具-本地安全策略-本地策略-用户分配权限</p>
</li>
<li>
<p>找到作为服务登录</p>
<figure data-type="image" tabindex="4"><img src="https://s1.ax1x.com/2020/06/08/tWu5b4.png" alt="tWu5b4.png" loading="lazy"></figure>
</li>
<li>
<p>然后重启一下，启动wsl2，查看hosts是否有wsl2的</p>
<ul>
<li>
<pre><code class="language-powershell">cat C:\Windows\System32\drivers\etc\hosts
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="terminal安装与美化">Terminal安装与美化</h3>
<h4 id="安装">安装</h4>
<ul>
<li>你可以直接在win10应用商店直接安装</li>
<li>也可以通过scoop安装</li>
</ul>
<pre><code class="language-powershell">scoop install windows-terminal
</code></pre>
<h4 id="美化与设置">美化与设置</h4>
<p><strong>tips:</strong></p>
<p>以下操作必须以管理员模式打开Powershell，如果询问你<code>yes or no</code>，直接选<code>A</code>，全部yes</p>
<ul>
<li>
<p>安装posh-git (前提你需要git，而且已经安装了git)</p>
<ul>
<li>安装git<code>scoop install git</code></li>
</ul>
</li>
<li>
<p><code>Install-Module posh-git -Scope CurrentUser</code></p>
</li>
<li>
<p>安装oh-mu-posh</p>
</li>
<li>
<p><code>Install-Module oh-my-posh -Scope CurrentUser</code></p>
</li>
<li>
<p>生成Powershell档案，类似<code>bashrc</code></p>
<ul>
<li>
<p><code>if (!(Test-Path -Path $PROFILE )) { New-Item -Type File -Path $PROFILE -Force }</code></p>
</li>
<li>
<p>编辑<code>$PROFILE</code>,你需要安装vscode或者自己找到该文件用记事本打开。</p>
<ul>
<li>
<p>若安装了vscode</p>
</li>
<li>
<pre><code class="language-powershell">code $PROFILE
</code></pre>
</li>
<li>
<pre><code class="language-powershell"># 写入以下文件
#禁用默认快捷键
Remove-PSReadlineKeyHandler 'Ctrl+r'
#导入模块(git)
Import-Module posh-git
Import-Module oh-my-posh
#设置主题
Set-Theme Paradox
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>允许powershell运行脚本(必须)</p>
<ul>
<li><code>set-executionpolicy remotesigned</code></li>
</ul>
</li>
<li>
<p>安装字体</p>
<ul>
<li>
<p><a href="https://github.com/adam7/delugia-code/releases/download/v1910.04.1/Delugia.Nerd.Font.Complete.ttf">下载字体</a>并且安装</p>
</li>
<li>
<p>打开terminal,点击设置，会弹出json配置文件</p>
</li>
<li>
<p>该json格式为<code>profiles{defaults,list[powershell,cmd,wsl]}</code>,list下面得就是对每一个实例得设置，你可以用icon设置tab列表显示得图片</p>
</li>
<li>
<pre><code class="language-json">//添加以下代码，到你需要应用这写设置得实例
“colorScheme&quot;: &quot;Campbell&quot;,

&quot;useAcrylic&quot;: true,

&quot;closeOnExit&quot;: false,

&quot;acrylicOpacity&quot;: 0.8,

&quot;fontFace&quot;: &quot;Delugia Nerd Font&quot;,
</code></pre>
</li>
</ul>
</li>
<li>
<p>然后重启Termina，大功告成，附我的设置，图片自己下载，路径自己改</p>
</li>
</ul>
<pre><code class="language-json">&quot;list&quot;:
        [
            {
                // Make changes here to the powershell.exe profile.
                &quot;guid&quot;: &quot;{61c54bbd-c2c6-5271-96e7-009a87ff44bf}&quot;,
                &quot;name&quot;: &quot;PowerShell&quot;,
                &quot;commandline&quot;: &quot;powershell.exe&quot;,
                &quot;useAcrylic&quot;: true,
                &quot;closeOnExit&quot;: false,
                &quot;acrylicOpacity&quot;: 0.7,
                &quot;colorScheme&quot; : &quot;Frost&quot;,
                &quot;cursorColor&quot; : &quot;#000000&quot;,
                &quot;fontFace&quot;: &quot;Delugia Nerd Font&quot;,
                &quot;hidden&quot;: false,
                &quot;icon&quot;: &quot;C:\\Users\\xstar\\AppData\\Local\\Terminal\\Powershell.png&quot;
 
            },
            {
                // Make changes here to the cmd.exe profile.
                &quot;guid&quot;: &quot;{0caa0dad-35be-5f56-a8ff-afceeeaa6101}&quot;,
                &quot;name&quot;: &quot;命令提示符&quot;,
                &quot;acrylicOpacity&quot;: 0.7,
                &quot;colorScheme&quot; : &quot;Frost&quot;,
                &quot;cursorColor&quot; : &quot;#000000&quot;,
                &quot;commandline&quot;: &quot;cmd.exe&quot;,
                &quot;hidden&quot;: false,
                &quot;icon&quot;: &quot;C:\\Users\\xstar\\AppData\\Local\\Terminal\\CMD.png&quot;
            },
            {
                &quot;guid&quot;: &quot;{a5a97cb8-8961-5535-816d-772efe0c6a3f}&quot;,
                &quot;hidden&quot;: false,
                &quot;name&quot;: &quot;Arch&quot;,
                &quot;tabTitle&quot;: &quot;Arch&quot;,
                &quot;suppressApplicationTitle&quot;: true,
                &quot;useAcrylic&quot;: true,
                &quot;acrylicOpacity&quot;: 0.7,
                &quot;colorScheme&quot; : &quot;Frost&quot;,
                &quot;cursorColor&quot; : &quot;#000000&quot;,
                &quot;fontFace&quot;: &quot;Delugia Nerd Font&quot;,
                &quot;source&quot;: &quot;Windows.Terminal.Wsl&quot;,
                &quot;icon&quot;: &quot;C:\\Users\\xstar\\AppData\\Local\\Terminal\\Arch.png&quot;
            },
            {
                &quot;guid&quot;: &quot;{b453ae62-4e3d-5e58-b989-0a998ec441b8}&quot;,
                &quot;hidden&quot;: false,
                &quot;name&quot;: &quot;Azure Cloud Shell&quot;,
                &quot;source&quot;: &quot;Windows.Terminal.Azure&quot;
            }
        ]
</code></pre>
<p>展示</p>
<figure data-type="image" tabindex="5"><img src="https://s1.ax1x.com/2020/06/13/tvm9YR.png" alt="tvm9YR.png" loading="lazy"></figure>
<h4 id="给terminal设置快捷键">给Terminal设置快捷键</h4>
<p>大部分人用久了linux，都很喜欢用<code>Ctrl+Alt+T</code>打开终端</p>
<p>找到你的Termianl快捷方式<code>右键-&gt;属性-&gt;快捷方式</code></p>
<p>在快捷键栏目直接按下<code>Ctrl+Alt+T</code>即可</p>
<figure data-type="image" tabindex="6"><img src="https://s1.ax1x.com/2020/06/13/tve6JI.png" alt="tve6JI.png" loading="lazy"></figure>
<p>接下来，享受你得windows</p>
<p>完结撒花👏👏</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring优雅的编写代码之基于注解的IOC]]></title>
        <id>https://seulg.github.io/post/spring-you-ya-de-bian-xie-dai-ma-zhi-ji-yu-zhu-jie-de-ioc/</id>
        <link href="https://seulg.github.io/post/spring-you-ya-de-bian-xie-dai-ma-zhi-ji-yu-zhu-jie-de-ioc/">
        </link>
        <updated>2020-02-14T03:38:24.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="spring-ioc的常用注解">spring IOC的常用注解</h2>
<ul>
<li>
<p>用于创建对象的</p>
<ul>
<li>
<p>他们的作用就和在XML中编写一个bean标签实现的功能是一致的</p>
</li>
<li>
<p><code>@Component</code></p>
<ul>
<li>作用:把当前类对象存入spring容器中</li>
<li>属性:
<ul>
<li>value : 用于指定bean的id,当我们不写时,它的默认值是当前类名首字母小写</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>@Controller</code> 一般用于表现层</p>
</li>
<li>
<p><code>@Service</code> 一般用于业务层</p>
</li>
<li>
<p><code>@Repository</code> 一般用于持久层</p>
</li>
</ul>
</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h2 id="spring-ioc的常用注解">spring IOC的常用注解</h2>
<ul>
<li>
<p>用于创建对象的</p>
<ul>
<li>
<p>他们的作用就和在XML中编写一个bean标签实现的功能是一致的</p>
</li>
<li>
<p><code>@Component</code></p>
<ul>
<li>作用:把当前类对象存入spring容器中</li>
<li>属性:
<ul>
<li>value : 用于指定bean的id,当我们不写时,它的默认值是当前类名首字母小写</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>@Controller</code> 一般用于表现层</p>
</li>
<li>
<p><code>@Service</code> 一般用于业务层</p>
</li>
<li>
<p><code>@Repository</code> 一般用于持久层</p>
</li>
</ul>
</li>
</ul>
<!-- more -->
<pre><code>上述三个注解的作用和属性与`Component`是一模一样的,是spring框架为我们提供明确的三层使用注解,是我们的三层对象更清晰(优雅)
</code></pre>
<ul>
<li>
<p>用于注入数据的</p>
<ul>
<li>和XML配置文件中bean写<code>property</code>标签是一致的</li>
<li><code>@Autowired</code>
<ul>
<li>作用:自动按照类型注入.只要容器中有唯一一个bean对象类型和要注入的变量类型匹配,就可以注入成功,<strong>如果IOC容器中有多个匹配时,会根据变量名去匹配IOC容器(map结构)中的key(id)</strong></li>
<li>出现位置:
<ul>
<li>可以是变量上,也可以是方法上(常用)</li>
</ul>
</li>
<li>细节: 使用注解时,set方法就不是必须的了</li>
</ul>
</li>
<li><code>@Qualifier</code>
<ul>
<li>作用: 在按照变量类型中注入的基础上再按照变量名注入.</li>
<li>细节: 再给类成员注入时不能单独使用,但是在给方法参数注入时可以单独使用</li>
<li>属性
<ul>
<li>value: 用于指定注入bean的id</li>
</ul>
</li>
</ul>
</li>
<li><code>@Resource</code>
<ul>
<li>作用: 直接按照id注入</li>
<li>属性:
<ul>
<li>name: 要注入值的id</li>
</ul>
</li>
</ul>
</li>
<li>以上三种注解只能注入其他bean类型数据,而基本类型和String类型无法用上述注解实现,另外集合类型的注入只能通过XML实现</li>
<li><code>@Value</code>
<ul>
<li>作用: 用于注入指定数据的值.可以使用spring的SpEL(spring表达式)
<ul>
<li>SpEL写法 ${表达式}</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>用于改变作用范围的</p>
<ul>
<li>和bean标签中使用<code>scope</code>属性的功能一致</li>
<li><code>@Scope</code>
<ul>
<li>作用:用于指定bean作用范围</li>
<li>属性:
<ul>
<li>value
<ul>
<li>singleton 单例(默认值)</li>
<li>prototype 多例</li>
</ul>
</li>
</ul>
</li>
<li>出现位置: 类上</li>
</ul>
</li>
</ul>
</li>
<li>
<p>和生命周期相关的(了解即可)</p>
<ul>
<li>和bean标签中<code>init-method</code>和<code>destory-method</code>的功能一致</li>
<li><code>@PreDestory</code>
<ul>
<li>作用: 用于指定销毁方法</li>
</ul>
</li>
<li><code>@PostConstruct</code>
<ul>
<li>作用: 用于指定初始化方法</li>
</ul>
</li>
<li>出现位置: 方法上</li>
</ul>
</li>
</ul>
<h2 id="案例使用xml方式实现表单的crud操作">案例使用XML方式实现表单的CRUD操作</h2>
<p><strong>采用dbutils，c3p0连接池,junit单元测试</strong></p>
<ul>
<li>bean.xml配置如下</li>
<li>采用xml方式需要在Service和dao添加set方法</li>
</ul>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!--配置Service--&gt;
    &lt;bean id=&quot;accountService&quot; class=&quot;com.henu.service.impl.AccountServiceImpl&quot;&gt;
        &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot; /&gt;
    &lt;/bean&gt;
    &lt;!--配置Dao对象--&gt;
    &lt;bean id=&quot;accountDao&quot; class=&quot;com.henu.dao.impl.IAccountDaoImpl&quot;&gt;
        &lt;!--注入QuereyRunner--&gt;
        &lt;property name=&quot;runner&quot; ref=&quot;runner&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;runner&quot; class=&quot;org.apache.commons.dbutils.QueryRunner&quot; scope=&quot;prototype&quot;&gt;
        &lt;!--注入数据源--&gt;
        &lt;constructor-arg name=&quot;ds&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;
    &lt;!--配置数据源--&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;
        &lt;!--连接数据库的信息--&gt;
        &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/springioc&quot;/&gt;
        &lt;property name=&quot;user&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;gyg06103234&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p><strong>QueryRunner</strong></p>
<p>核心类</p>
<ul>
<li>QueryRunner(DataSource ds);  传入参数为连接池</li>
<li>pdate(String sql, Object… params) ;  执行insert update delete操作</li>
<li>query(String sql, ResultSetHandler rsh, Object… params) ;  执行 select操作</li>
</ul>
<p><strong>ResultSetHandler</strong></p>
<p>结果集处理类</p>
<figure data-type="image" tabindex="1"><img src="https://s1.ax1x.com/2020/03/16/8JVel4.png" alt="8JVel4.png" loading="lazy"></figure>
<h2 id="改造上述案例使用纯注解方式实现">改造上述案例,使用纯注解方式实现</h2>
<p>修改bean.xml约束：</p>
<pre><code class="language-xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;context:annotation-config/&gt;
</code></pre>
<ul>
<li>
<p>去掉Service和dao的注解</p>
<ul>
<li>
<p>删除Service中dao的set方法以及dao中QueryRunner的set方法</p>
</li>
<li>
<p>在类名上分别添加<code>@Service(accountService)</code>注解和<code>@Repository(&quot;accountDao&quot;)注解</code></p>
</li>
<li>
<p>分别在两个成员变量上加入<code>@AutoWrite</code>注解即可，因为ioc容器中只存在唯一的对应对象</p>
</li>
</ul>
</li>
<li>
<p>去掉所有注解</p>
<ul>
<li><code>Configuration</code> 指定当前类是一个配置类
<ul>
<li>当该类作为<code>AnnotationConfigApplicationContext</code>的参数时可以不加此注解</li>
<li>作为参数就不用指定扫描范围,不作为参数就要指定扫描范围</li>
</ul>
</li>
<li><code>ComponentScan</code>指定扫描包的范围
<ul>
<li>默认属性<code>value</code>和<code>basePackage</code>任选一</li>
<li>数组类型的注解,如果只有一个值,可以去掉大括号</li>
</ul>
</li>
<li><code>Bean</code> 把当前方法的返回值作为bean对象存入ioc容器中
<ul>
<li>name:用于指定bean的id
<ul>
<li>默认值为当前方法的名称</li>
</ul>
</li>
<li>当使用<code>@Bean</code>注解配置方法时,如果有参数时,spring会按照<code>Autowired</code>的方式查找ioc容器中是否有唯一的对应变量的bean对象</li>
</ul>
</li>
<li><code>import</code>用于导入其他的配置类
<ul>
<li><code>value</code>其他配置类字节码文件数组</li>
<li>把其他的配置类都加入到主配置类
<ul>
<li>只用加载主配置类,就可以加载所有配置类</li>
</ul>
</li>
</ul>
</li>
<li><code>PropertySource</code>导入配置文件
<ul>
<li>value:指定文件的名称和路径</li>
<li><code>classpath:</code>指定类路径下</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="spring-和-junit整合">spring 和 Junit整合</h2>
<ul>
<li>导入<code>spring-test</code>依赖</li>
</ul>
<pre><code class="language-xml">&lt;dependency&gt;
	&lt;groupId&gt;org.springframework&lt;/groupId&gt;
	&lt;artifactId&gt;spring-test&lt;/artifactId&gt;
	&lt;version&gt;5.0.2.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>使用Junit提供的注解把原有的main方法替换成spring提供的main方法</li>
</ul>
<pre><code class="language-java">@RunWith(SpringJUnit4ClassRunner.class)
</code></pre>
<ul>
<li>告知spring的运行器,spring和ioc的创建是基于注解还是xml,并且说明位置
<ul>
<li>locations:指定xml文件位置,加上<code>classpath</code>关键字,表示在类路径下</li>
<li>classes:指定注解类所在的位置</li>
</ul>
</li>
</ul>
<pre><code class="language-java">@ContextConfiguration(classes = SpringConfiguration.class)
</code></pre>
<ul>
<li>当使用spring5.x版本的时候,要求Junit的版本必须是4.12及以上</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[初识Spring之IOC,DI]]></title>
        <id>https://seulg.github.io/post/chu-shi-spring-zhi-iocdi/</id>
        <link href="https://seulg.github.io/post/chu-shi-spring-zhi-iocdi/">
        </link>
        <updated>2020-02-13T06:48:51.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="ioc控制反转">IOC(控制反转)</h2>
<pre><code>IOC是Spring框架的核心容器,任何Spring框架的模块都依赖于此容器,因此,在学习Spring时,一定要注意理解IOC容器的含义.
</code></pre>
<h3 id="ioc主要解决了什么问题">IOC主要解决了什么问题?</h3>
<h3 id="耦合">耦合</h3>
<p>​    先不着急给出答案,我们先来看一下,web持久层中的数据库链接是如何建立对象的<br>
准备工作,创建数据库<code>demo</code>,然后创建表account,</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="ioc控制反转">IOC(控制反转)</h2>
<pre><code>IOC是Spring框架的核心容器,任何Spring框架的模块都依赖于此容器,因此,在学习Spring时,一定要注意理解IOC容器的含义.
</code></pre>
<h3 id="ioc主要解决了什么问题">IOC主要解决了什么问题?</h3>
<h3 id="耦合">耦合</h3>
<p>​    先不着急给出答案,我们先来看一下,web持久层中的数据库链接是如何建立对象的<br>
准备工作,创建数据库<code>demo</code>,然后创建表account,</p>
<!-- more -->
<pre><code class="language-mysql">create table account(
	id int primary key auto_increment,
    name varhchar(40),
    money float
) character set utf8 collate utf8_general_ci;
插入数据
insert into account(name,money) values('gyg',1000);
insert into account(name,money) values('gyk',1200);
insert into account(name,money) values('gyl',1500);
</code></pre>
<p>添加mysql依赖坐标</p>
<pre><code class="language-xml">&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;5.1.6&lt;/version&gt;
        &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>JDBCDemo如下:</p>
<pre><code class="language-java">public class JDBCDemo {
    public static void main(String[] args) throws Exception{
        //1.注册驱动
        DriverManager.registerDriver(new com.mysql.jdbc.Driver());
        //2.获取连接
        Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/demo&quot;,&quot;root&quot;,&quot;gyg06103234&quot;);
        //3.获取操作数据库预处理对象
        PreparedStatement pstm = conn.prepareStatement(&quot;select * from account&quot;);
        //4.通过sql语句,查询数据库得到结果集
        ResultSet rs = pstm.executeQuery();
        //5.遍历结果集
        while (rs.next()) {
            System.out.println(rs.getString(&quot;name&quot;)+&quot; &quot;+ rs.getString(&quot;money&quot;));
        }
        //6.释放资源
        rs.close();
        pstm.close();
        conn.close();
    }
}
</code></pre>
<p>此时如果在pom.xml中把mysql驱动注释掉,就会出现编译时异常,如果你用的是高级的IDE(例如IDEA),会直接提示错误Cannot resolve symbol 'mysql',因为在编译的时候找不到驱动,肯定会报错,这就是<code>程序的耦合</code>:</p>
<ul>
<li>类之间的耦合</li>
<li>方法之间的耦合</li>
<li>需要注意耦合无法完全消除,只能降低耦合(这个过程就是解耦)</li>
</ul>
<p>实际开发中应做到,编译器不依赖,运行期依赖</p>
<p>上述例子中解耦的方式想家都知道,例如注册驱动的解耦</p>
<pre><code class="language-java">//1.注册驱动
//DriverManager.registerDriver(new com.mysql.jdbc.Driver());
Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
</code></pre>
<p>此时,在编译期并不会报错,但是程序并不能运行,因为没有依赖,这就做到了把<code>编译期依赖转换成运行时依赖</code></p>
<p>总结一下上述做法</p>
<ul>
<li>创建对象时,使用反射创建,避免使用<code>new</code>关键字(上述例子中可以看出,一个是依赖类,另一个是依赖字符串,但是上述做法有一个问题 驱动类是写死的,更换数据库仍然需要修改)</li>
<li>通过读取配置文件的形式,获取要创建对象的全限定类名</li>
</ul>
<p>我们依旧可以举一个保存账户的例子</p>
<p>目录结构如下:</p>
<figure data-type="image" tabindex="1"><img src="https://s2.ax1x.com/2020/02/03/1aFkfe.png" alt="1aFkfe.png" loading="lazy"></figure>
<p>可以看出在ui.Client里面类的耦合程度很高,那么该如何解决这个问题呢?</p>
<p>根据上一个例子,我们依然可以采用反射的方式,将类名存在一个配置文件,然后建立一个工厂类,读取配置文件,创建对象,这样在ui.Client就不用依赖具体的类,而只依赖类的全限定类名(字符串),这就实现了解耦</p>
<p>具体做法如下:</p>
<p>创建factory.BeanFactory类内容如下:</p>
<pre><code class="language-java">public class BeanFactory {
    private static Properties props;
    static {
        try {
            //1.实例化对象
            props = new Properties();
            //2.获取propertoes流对象
            InputStream in = BeanFactory.class.getClassLoader().getResourceAsStream(&quot;be
        } catch (Exception e) {
            throw new ExceptionInInitializerError(&quot;初始化properties文件失败&quot;);
        }
    }
     public static Object getBean(String beanName) {
        Object bean = null;
        try {
            String beanPath = props.getProperty(beanName);
            bean = Class.forName(beanPath).newInstance();
        } catch (Exception e) {
            e.printStackTrace();
        }

        return beans.get(beanName);
    }
}
</code></pre>
<p>这样就可以通过工厂模式创建对象</p>
<p>此时可以将ui.Client和service.AccountServiceImpl修改为:</p>
<pre><code class="language-java">public class Client {
    public static void main(String[] args) {
        //IAccountService as = new AccountServiceImpl();
        IAccountService as = (IAccountService)BeanFactory.getBean(&quot;accountService&quot;);
        as.saveAccount();
    }
}


public class AccountServiceImpl implements IAccountService {
    private IAccountDao accountDao = (IAccountDao) BeanFactory.getBean(&quot;accountDao&quot;);
    public void saveAccount() {
        accountDao.saveAccount();
    }
}

</code></pre>
<p>这样就降低了类之间的耦合,实现方式如上述例子中的相似,都是通过反射的方式解耦</p>
<h3 id="多例化对象问题">多例化对象问题</h3>
<p>但是此时,我们会发现每次通过<code>IAccountService as = (IAccountService)BeanFactory.getBean(&quot;accountService&quot;);</code>获取对象,都是一个新的对象,不是从始至终都是一个对象.这就是多例化对象</p>
<ul>
<li>
<p>多例化对象会创建多次,效率低</p>
</li>
<li>
<p>但是,多例化对象更加适用于多线程,因为每个对象都是独立的</p>
</li>
<li>
<p>当然,如果对象中存在成员变量,则可能多线程兼容不太好</p>
</li>
<li>
<p>所以应该尽可能的把成员变量加入到成员方法中</p>
</li>
</ul>
<p>在web中一般并没有多少成员变量,因此一般使用单例化创建对象</p>
<p>那么该如何解决呢?</p>
<p>我们可以在读取完配置文件后就创建所有对象,存入一个HashMap容器(这已经类似于IOC容器了)中,如果不保存,可能会因为java的垃圾处理机制导致对象被回收,然后修改getBean,返回Map中对应的value</p>
<p>修改factory.BeanFactory如下:</p>
<pre><code class="language-java">public class BeanFactory {
    private static Properties props;
    private static Map&lt;String,Object&gt; beans;
    static {
        try {
            //1.实例化对象
            props = new Properties();
            //2.获取propertoes流对象
            InputStream in = BeanFactory.class.getClassLoader().getResourceAsStream(&quot;bean.properties&quot;);
            props.load(in);
            //3.实例化容器
            beans = new HashMap&lt;String, Object&gt;();
            //4.取出配置文件中的所有key
            Enumeration keys = props.keys();
            //5.遍历枚举,取出key
            while (keys.hasMoreElements()) {
                String key = keys.nextElement().toString();
                //6.根据key获取value 反射创建对象
                String beanPath = props.getProperty(key);
                Object value = Class.forName(beanPath).newInstance();
                //7.存入Map
                beans.put(key,value);
            }
        } catch (Exception e) {
            throw new ExceptionInInitializerError(&quot;初始化properties文件失败&quot;);
        }
    }
    public static Object getBean(String beanName) {
       return beans.get(beanName);
    }
}

</code></pre>
<p>这就解决了多例化对象的问题</p>
<p>至此,我们就已经模拟了<code>spring ioc</code>的设计模式,即通过配置文件方式,用工厂模式创建对象</p>
<h3 id="ioc的理解">IOC的理解</h3>
<pre><code class="language-java">//IAccountService as = new AccountServiceImpl();
IAccountService as = (IAccountService)BeanFactory.getBean(&quot;accountService&quot;);
</code></pre>
<p>这两句话就体现了IOC为何称之为控制反转</p>
<ul>
<li>
<p>第一种方式(被注释掉的),是程序员自主的创建一个对象,拥有这个对象的所有控制权</p>
</li>
<li>
<p>第二种方式,则将创建对象的权利交给了工厂,这就是控制反转</p>
</li>
<li>
<p>工厂得到的对象由配置文件控制</p>
</li>
<li>
<p>当然程序员有权选啧这两种创建方式</p>
</li>
</ul>
<p>IOC含义:</p>
<p><strong>控制反转</strong>（Inversion of Control，缩写为<strong>IoC</strong>），是<a href="https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B">面向对象编程</a>中的一种设计原则，可以用来减低计算机代码之间的<a href="https://baike.baidu.com/item/%E8%80%A6%E5%90%88%E5%BA%A6">耦合度</a>。其中最常见的方式叫做<strong>依赖注入</strong>（Dependency Injection，简称<strong>DI</strong>），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。(来自百度百科)</p>
<h3 id="ioc解决了什么问题">IOC解决了什么问题</h3>
<pre><code class="language-mermaid">graph LR
	App --&gt; 资源1
	App --&gt; 资源2
	App --&gt; 资源3
	
</code></pre>
<p>原始的创建对象的方式，App和资源之间依赖关系很强,而IOC模式为</p>
<pre><code class="language-mermaid">graph LR
	App --获取资源--&gt; 工厂
	工厂 --控制--&gt; 资源1
	工厂 --控制--&gt; 资源2
	工厂 --控制--&gt; 资源3
</code></pre>
<ul>
<li>
<p>IOC解决了app和资源之间依赖关系,使得App和资源的独立更方便</p>
</li>
<li>
<h3 id="ioc降低了类之间耦合程度">IOC降低了类之间耦合程度</h3>
</li>
</ul>
<h2 id="spring-ioc">Spring IOC</h2>
<p>​	通过Spring获取Ioc容器可分为两种:</p>
<ul>
<li>通过xml配置文件</li>
<li>通过注解</li>
</ul>
<h3 id="可以通过applicationcontext接口获取核心容器该接口有三个常用实现类">可以通过ApplicationContext接口获取核心容器,该接口有三个常用实现类</h3>
<ul>
<li>ClassPathApplicationContext 顾名思义就是 读取类路径下的配置文件</li>
<li>SystemXmlApplicationContext 同上,系统内的xml文件(需要有读取权限)</li>
<li>AnnotationConfigApplicationContext 通过注解的方式取得核心容器</li>
</ul>
<p>我们先来了解前两种通过xml配置文件的方式</p>
<p>maven工程在resource文件夹下创建bean.xml,这个文件名可以任意(非中文),但是有一个约定俗成的文件名<code>applicationContext.xml</code>暂时先使用bean.xml</p>
<p>添加一下约束条件</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;accountService&quot; class=&quot;com.henu.service.impl.AccountServiceImpl&quot;/&gt;
    &lt;bean id=&quot;accountDao&quot; class=&quot;com.henu.dao.impl.AccountDaoImpl&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<p>联想前面的bean.properties文件内容,不难发现属性id必须是唯一的,class属性就是该类的全限定类名,<code>此配置文件到后面还会细说,此处可以先用</code></p>
<pre><code class="language-java">ApplicationContext context = new ClassPathApplicationContext(&quot;bean.xml&quot;);
</code></pre>
<p>这个context便类似于上面模拟的BeanFactory,即为spring的核心容器,接下来就可以使用此容器,根据配置的id获取对象了</p>
<ul>
<li>可以直接传入id获取Object对象然后强转</li>
</ul>
<pre><code class="language-java">IAccountService ac = (IAccountService)context.getBean(&quot;accountService&quot;);
</code></pre>
<ul>
<li>亦可以传入class,直接获得对应对象</li>
</ul>
<pre><code class="language-java">IAccountService ac = context.getBean(&quot;accountService&quot;,IAccountServiceImpl.class);
</code></pre>
<h3 id="applicationcontext创建容器的细节">ApplicationContext创建容器的细节:</h3>
<ul>
<li>一旦读取完配置文件,立马创建配置文件内配置的对象</li>
<li>适用于单例对象的创建</li>
</ul>
<p>当然还有另一种方式就是采用顶层接口BeanFactory</p>
<p>先展示一下接口间的依赖关系</p>
<figure data-type="image" tabindex="2"><img src="https://s2.ax1x.com/2020/02/14/1XY658.png" alt="1XY658.png" loading="lazy"></figure>
<p>可以看出BeanFactory是一个顶层接口(也就意味着功能不是特别强大)</p>
<p>我们用BeanFactory(已经过时了的)的方式获取:</p>
<pre><code class="language-java">Resource resource = new ClassPathResource(&quot;bean.xml&quot;);
BeanFactory factory = new XmlBeanFactory(resource);
IAccountService as = (IAccountService)factory.getBean(&quot;accountService&quot;);
</code></pre>
<p>BeanFactory区别于ApplicationContext采用的立即加载策略</p>
<ul>
<li>采用的是延迟加载的策略,即要真正获取对象时才会创建对象</li>
<li>适用于多例对象的创建</li>
</ul>
<h3 id="如何验证">如何验证?</h3>
<p>我们可以在IAccountService中加入一个默认构造器,输出一句话(service对象已经创建)</p>
<p>然后分别在两种方式读取配置文件时打断点</p>
<p>ApplicationContext:</p>
<p><img src="https://s2.ax1x.com/2020/02/14/1XY28g.png" alt="1XY28g.png" loading="lazy">BeanFactory:</p>
<figure data-type="image" tabindex="3"><img src="https://s2.ax1x.com/2020/02/14/1XY75T.png" alt="1XY75T.png" loading="lazy"></figure>
<p>红色是断点位置,绿色是下一步要执行的即,此步执行的是绿色上面的语句,很容易就能看出两种方式区别</p>
<h3 id="spring对bean对象的管理细节">spring对bean对象的管理细节</h3>
<ul>
<li>创建对象的三种方式</li>
<li>bean对象的作用范围</li>
<li>bean对象的生命周期</li>
</ul>
<h3 id="创建对象的三种方式">创建对象的三种方式</h3>
<ul>
<li>
<p>使用默认构造函数创建</p>
<p>在spring的配置文件中用bean标签配置id和class属性后,没有其他的标签和属性,就采用默认构造函数创建bean对象,此时如果类中无默认构造函数,则无法创建</p>
</li>
</ul>
<pre><code class="language-xml">&lt;bean id=&quot;accountService&quot; class=&quot;com.henu.service.impl.AccountServiceImpl&quot;/&gt;
&lt;bean id=&quot;accountDao&quot; class=&quot;com.henu.dao.impl.AccountDaoImpl&quot;/&gt;
</code></pre>
<ul>
<li>使用类中成员方法创建对象,存入spring容器(非静态方法返回值)</li>
</ul>
<pre><code class="language-java">//创建一个简单工厂类进行模拟
factory.InstanceFactory
    
public class InstanceFactory {
    public IAccountService getAccountService() {
        return new AccountServiceImpl();
    }
}
</code></pre>
<pre><code class="language-xml">&lt;bean id=&quot;instanceFactory&quot; class=&quot;com.henu.factory.InstanceFactory&quot;/&gt;
&lt;bean id=&quot;accountService&quot; factory-bean=&quot;instanceFactory&quot; factory-method=&quot;getAccountService&quot; /&gt;
</code></pre>
<p>可以通过此方式创建accountService对象</p>
<p>factory-bean属性值为 类的id<code>必须提前编写此类的bean标签</code></p>
<p>factory-method属性值为 类中用于生成对象的方法名</p>
<ul>
<li>使用类中静态方法返回值创建对象(静态方法返回值)</li>
</ul>
<p>将上述工厂类中的方法加上<code>static</code>修饰符,可以通过以下配置文件创建</p>
<pre><code class="language-xml">&lt;bean id=&quot;accountService&quot; class=&quot;com.henu.factory.InstanceFactory&quot; factory-method=&quot;getAccountService&quot; /&gt;
</code></pre>
<p><strong>其中后两种方法适用于jar文件中的类</strong></p>
<h3 id="bean对象的作用范围">bean对象的作用范围</h3>
<ul>
<li>
<p>bean标签scope属性</p>
<p>作用:指定bean的作用范围</p>
<p>取值:</p>
<p>​	<code>singleton</code> :单例的,默认值</p>
<p>​	<code>prototype</code>:多例的</p>
<p>​	<code>request</code>:作用于web应用请求范围</p>
<p>​	<code>session</code>:作用web应用会话范围</p>
<p>​	<code>global-session</code>:作用于集群环境的会话范围(雾)</p>
<p>只验证前两个值</p>
<pre><code class="language-java">&lt;bean id=&quot;accountDao&quot; class=&quot;com.henu.dao.impl.AccountDaoImpl&quot; scope=&quot;singleton&quot;/&gt;
    
IAccountDao dao1 = ac.getBean(&quot;accountDao&quot;,IAccountDao.class);
IAccountDao dao2 = ac.getBean(&quot;accountDao&quot;,IAccountDao.class);
System.out.println(dao1==dao2); //true,证明只创建了一次对象,即是单例对象

&lt;bean id=&quot;accountDao&quot; class=&quot;com.henu.dao.impl.AccountDaoImpl&quot; scope=&quot;prototype&quot;/&gt;
IAccountDao dao1 = ac.getBean(&quot;accountDao&quot;,IAccountDao.class);
IAccountDao dao2 = ac.getBean(&quot;accountDao&quot;,IAccountDao.class);
System.out.println(dao1==dao2); //false,证明只创建了两次次对象,即是多例对象    
</code></pre>
</li>
<li>
<p>bean对象的生命周期</p>
<p>单例对象:</p>
<p>​	出生:容器创建时,对象就被创建</p>
<p>​	活着:容器存在时.对象就存在</p>
<p>​	死亡:容器销毁,对象狗带</p>
<p>​	总结单例对象生命周期与容器一致</p>
<pre><code class="language-java">//bean 标签指定初始化方法和销毁方法,在AccountDaoimpl类中添加相应方法
&lt;bean id=&quot;accountDao&quot; class=&quot;com.henu.dao.impl.AccountDaoImpl&quot; scope=&quot;singleton&quot; init-method=&quot;init&quot; destroy-method=&quot;destory&quot;/&gt;
 
public void init() {
    System.out.println(&quot;对象被创建了&quot;);
}
public void destory() {
    System.out.println(&quot;对象销毁了&quot;);
}
/* 结果正确的输出了&quot;对象被创建了&quot;,没有输出对象被销毁了
 * why? 在main方法执行完毕后,就会把当前应用中线程栈中的内存就会被全部释放,但是还并没有调用销毁方法
 * 需要手动释放方法才能调用销毁方法
 * 在main方法中作出如下修改
 **/

//ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);java多态的体现
ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
//添加
ac.close();
//此时,销毁方法便会正常执行
</code></pre>
<p>多例对象</p>
<p>​	出生:当要使用对象时,spring才会创建,验证方法与上文类似,打断点即可</p>
<p>​	活着 : 对象在使用过程中,就会一直活着</p>
<p>​	死亡: 当对象长时间不使用,且没有别的对象引用时,由Java的垃圾回收器销毁</p>
</li>
</ul>
<h2 id="依赖注入dependency-injection">依赖注入Dependency Injection</h2>
<ul>
<li>
<p>IOC作用:</p>
<p>​	降低程序间的耦合(依赖关系)</p>
</li>
<li>
<p>依赖关系</p>
<p>​	在当前类需要用到其他类的对象,由spring提供,只需在配置文件说明</p>
</li>
<li>
<p>依赖关系的管理</p>
<p>​	交给spring管理和维护</p>
</li>
<li>
<p>依赖注入</p>
<ul>
<li>
<p>能注入的数据</p>
<ul>
<li>基本类型和String</li>
<li>其他bean类型(在配置文件中或者注释配置过的)</li>
<li>复杂类型/集合类型</li>
</ul>
</li>
<li>
<p>注入方式</p>
<ul>
<li>
<p>使用构造函数提供</p>
</li>
<li>
<p>使用set方法提供</p>
</li>
<li>
<p>使用注解提供(雾)</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>例如, 我们将AccountService修改为:</p>
<pre><code class="language-java">public class AccountServiceImpl implements IAccountService {
    private String name;
    private Integer age;
    private Date birthday;

    public AccountServiceImpl(String name,Integer age, Date birthday) {
        this.name = name;
        this.age = age;
        this.birthday = birthday;
    }
    public void saveAccount() {
        System.out.println(name + &quot; &quot; + age + &quot; &quot; + &quot; &quot; + birthday);
    }

}
</code></pre>
<h3 id="构造函数注入">构造函数注入</h3>
<p>使用 <code>constructor-arg</code>标签</p>
<ul>
<li>
<p>type :用于指定要注入数据的类型,该类型必须是构造函数中某个或默写参数的类型</p>
</li>
<li>
<p>index:用于指定要注入数据给构造函数中指定索引位置的参数赋值,起始值为<strong>0</strong></p>
</li>
<li>
<p>name: 用于给构造函数中指定名称的参数赋值(常用)</p>
<p>--------------用于指定给构造函数中哪个参数赋值--------------</p>
</li>
<li>
<p>value: 用于提供基本类型和String类型的数据</p>
</li>
<li>
<p>ref: 用于指定在spring核心容器ioc中出现过的bean对象</p>
</li>
</ul>
<p>因此可以用以下配置文件</p>
<pre><code class="language-xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;accountService&quot; class=&quot;com.henu.service.impl.AccountServiceImpl&quot;&gt;
        &lt;constructor-arg name=&quot;name&quot; value=&quot;test&quot;/&gt;
        &lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;/&gt;
        &lt;constructor-arg name=&quot;birthday&quot; value=&quot;1999-11-23&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p><strong>注意:</strong></p>
<ul>
<li>配置文件里面所有的value都是字符串</li>
<li>Integer 可以 直接用字符串类型的18赋值(spring可以强转)</li>
<li>Date类型不能直接用字符串&quot;1999-11-23&quot;</li>
</ul>
<p>因此上述配置文件是错误的,需要作出如下修改</p>
<pre><code class="language-xml">&lt;bean id=&quot;accountService&quot; class=&quot;com.henu.service.impl.AccountServiceImpl&quot;&gt;
    &lt;constructor-arg name=&quot;name&quot; value=&quot;test&quot;/&gt;
    &lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;/&gt;
    &lt;constructor-arg name=&quot;birthday&quot; ref=&quot;now&quot;/&gt;
&lt;/bean&gt;
&lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;/&gt;
</code></pre>
<p><strong>优势:</strong></p>
<p>​	在获取bean对象时,诸如数据是必须操作,否则无法创建对象(没有默认构造参数)</p>
<p><strong>弊端:</strong></p>
<p>​	改变了bean对象的实例化方式,使我们在创建对象时,如果用不到这些数据,也必须提供</p>
<h3 id="set方法注入更常用">set方法注入(更常用)</h3>
<p>使用<code>property</code>标签</p>
<ul>
<li>name: 用于指定注入时调用的set方法名称(与成员变量名无关,只与set方法名称有关,去掉set,首字母变小写)</li>
<li>value: 用于提供基本类型和String类型的数据</li>
<li>ref: 用于指定在spring核心容器ioc中出现过的bean对象</li>
</ul>
<p>在AccountService中生成setter方法,并且注释掉带参构造函数</p>
<pre><code class="language-java">public void setUserName(String name) {
    this.name = name;
}
public void setAge(Integer age) {
     this.age = age;
}
public void setBirthday(Date birthday) {
    this.birthday = birthday;
}
</code></pre>
<p>则配置文件可以这么写</p>
<pre><code class="language-xml">&lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;/&gt;
&lt;bean id=&quot;accountService&quot; class=&quot;com.henu.service.impl.AccountServiceImpl&quot;&gt;
    &lt;property name=&quot;userName&quot; value=&quot;qaq&quot;/&gt;
    &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;
    &lt;property name=&quot;birthday&quot; ref=&quot;now&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p><strong>优势:</strong></p>
<p>​	创建对象时没有限制,可以使用默认构造函数</p>
<p><strong>弊端:</strong></p>
<p>​	如果某个成员必须有值,则获取对象时,set方法没有执行</p>
<h3 id="复杂类型集合类型注入">复杂类型/集合类型注入</h3>
<ul>
<li>
<p>用于给List结构注入的标签有</p>
<p><code>list</code> <code>array</code> <code>set</code></p>
</li>
<li>
<p>用于给Map结构注入的标签有</p>
<p><code>map</code> <code>props</code></p>
</li>
<li>
<p>结构相同,标签可以互换</p>
</li>
</ul>
<p>修改AccountService</p>
<pre><code class="language-java">private String[] myStrings;
private List&lt;String&gt; myList;
private Set&lt;String&gt; mySet;
private Map&lt;String,String&gt; myMap;
private Properties myProps;
public void saveAccount() {
    System.out.println(Arrays.toString(myStrings));
    System.out.println(myList);
    System.out.println(mySet);
    System.out.println(myMap);
    System.out.println(myProps);
}

public void setMySet(Set&lt;String&gt; mySet) {
    this.mySet = mySet;
}

public void setMyProps(Properties myPops) {
    this.myProps = myPops;
}

public void setMyStrings(String[] myStrings) {
    this.myStrings = myStrings;
}

public void setMyList(List&lt;String&gt; myList) {
    this.myList = myList;
}

public void setMyMap(Map&lt;String, String&gt; myMap) {
    this.myMap = myMap;
}
</code></pre>
<p>依旧可以使用set方式注入</p>
<pre><code class="language-xml">
&lt;bean id=&quot;accountService&quot; class=&quot;com.henu.service.impl.AccountServiceImpl&quot; &gt;
    &lt;property name=&quot;myStrings&quot;&gt;
        &lt;set&gt;
            &lt;value&gt;AAA&lt;/value&gt;
            &lt;value&gt;BBB&lt;/value&gt;
            &lt;value&gt;CCC&lt;/value&gt;
        &lt;/set&gt;
    &lt;/property&gt;
    &lt;property name=&quot;myList&quot;&gt;
        &lt;array&gt;
            &lt;value&gt;AAA&lt;/value&gt;
            &lt;value&gt;BBB&lt;/value&gt;
            &lt;value&gt;CCC&lt;/value&gt;
        &lt;/array&gt;
    &lt;/property&gt;
    &lt;property name=&quot;mySet&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;AAA&lt;/value&gt;
            &lt;value&gt;BBB&lt;/value&gt;
            &lt;value&gt;CCC&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name=&quot;myMap&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;A&quot; value=&quot;a&quot; /&gt;
            &lt;entry key=&quot;B&quot;&gt;
                &lt;value&gt;b&lt;/value&gt;
            &lt;/entry&gt;
        &lt;/map&gt;
    &lt;/property&gt;
    &lt;property name=&quot;myProps&quot;&gt;
        &lt;props&gt;
            &lt;prop key=&quot;AA&quot;&gt;aa&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p><strong>基于xml的spring ioc di到此结束</strong>,明天继续注解ioc(雾)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git -版本控制工具]]></title>
        <id>https://seulg.github.io/post/git-版本控制工具/</id>
        <link href="https://seulg.github.io/post/git-版本控制工具/">
        </link>
        <updated>2019-11-28T05:05:16.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="git-分布式版本控制系统">Git 分布式版本控制系统</h2>
<h3 id="底层命令">底层命令</h3>
<h4 id="git对象">git对象</h4>
<ul>
<li>git对象</li>
<li>树对象</li>
<li>提交对象</li>
</ul>
<h5 id="git对象-2">git对象</h5>
<h6 id="命令介绍">命令介绍</h6>
<ul>
<li>
<p><code>git init</code>在工作区下,初始化仓库</p>
</li>
<li>
<p><code>echo “test” | git hash-object -w --stdin</code></p>
</li>
<li>
<p>-stdin (standard input)从标准输入流读取数据 ,也可以是文件路径(对文件进行版本控制)</p>
<ul>
<li>-w 存入版本库(.git/object),若不加则不会存,仅输出哈希值</li>
</ul>
</li>
<li>
<p><code>git cat-file -p 哈希值</code>查看文件内容</p>
</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h2 id="git-分布式版本控制系统">Git 分布式版本控制系统</h2>
<h3 id="底层命令">底层命令</h3>
<h4 id="git对象">git对象</h4>
<ul>
<li>git对象</li>
<li>树对象</li>
<li>提交对象</li>
</ul>
<h5 id="git对象-2">git对象</h5>
<h6 id="命令介绍">命令介绍</h6>
<ul>
<li>
<p><code>git init</code>在工作区下,初始化仓库</p>
</li>
<li>
<p><code>echo “test” | git hash-object -w --stdin</code></p>
</li>
<li>
<p>-stdin (standard input)从标准输入流读取数据 ,也可以是文件路径(对文件进行版本控制)</p>
<ul>
<li>-w 存入版本库(.git/object),若不加则不会存,仅输出哈希值</li>
</ul>
</li>
<li>
<p><code>git cat-file -p 哈希值</code>查看文件内容</p>
</li>
</ul>
<!-- more -->
<h6 id="测试">测试</h6>
<pre><code class="language-git">echo “test” | git hash-object -w --stdin  
bd721793c916757eb17ffc248799ad00f0b35735 (输出的哈希值就是&quot;test&quot;的唯一标示,只与内容有关,内容改变,哈希值也改变)
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2019/11/28/numF5cWHDtjdSye.png" alt="git对象.png" loading="lazy"></figure>
<p>如图: 命名方式为 哈希值前位为文件夹,后面的为文件名</p>
<pre><code class="language-git"># 查看文件内容
git cat-file -p bd721793c916757eb17ffc248799ad00f0b35735
“test”
</code></pre>
<p>如果直接用cat 命令,则会乱码,证明内容被压缩过</p>
<pre><code class="language-git">cat .git//objects/bd/721793c916757eb17ffc248799ad00f0b35735
xK��OR04dx�0�$���Q�\.IR�% 
</code></pre>
<p>说明了一个问题,git将用户的文件或者内容,生成唯一hash值,并压缩数据</p>
<pre><code class="language-git">echo “test v1” &gt; test.txt
git hash-object -w ./test.txt
89f9ceab790a0662e30ff1f2f3e8bac0bf7fd895 (输出,若文件内的内容仍然是test,则哈希值不变,证明,保存的仍然是文件内容)
</code></pre>
<p>若修改文件内容,git并不会自动记录修改内容,必须再显式提交一次</p>
<pre><code class="language-git">vim test.txt 
输入一些内容
git hash-object -w ./test.txt
会输出一个新的hash值
</code></pre>
<p>object目录下会多出来一个文件,也就是说git不是增量修改</p>
<h6 id="git对象的问题">git对象的问题:</h6>
<ul>
<li>记住文件的每一个版本对应的hash值并不现实</li>
<li>在git中,文件名没有被保存,仅保存了文件内容</li>
<li>这些操作都是在本地数据库(git实质上就是一个简单数据库)操作,不涉及暂存区</li>
<li>git对象并不能表示项目的快照,仅代表每个文件内容的快照</li>
<li>只能通过哈希值读取文件内容</li>
</ul>
<h5 id="树对象tree-object">树对象(tree object)</h5>
<p>能解决文件名的保存,并且允许我们将多个文件组织在一起</p>
<h6 id="命令介绍-2">命令介绍</h6>
<ul>
<li><code>git ls-files -s</code>查看树对象的样子,(这个命令其实是查看暂存区的,树对象存在暂存区,git对象不涉及暂存区操作)</li>
<li><code>git update-index --add --cacheinfo 100644 bd721793c916 757eb17ffc248799ad00f0b35735 test.txt</code> 创建树对象,不在版本库存储东西
<ul>
<li>
<p>–add:因为目前文件不在暂存区,首次创建树对象才需要</p>
</li>
<li>
<p>-cacheinfo:要把需要添加的文件存入数据库,而不是挡墙目录</p>
</li>
<li>
<p>文件模式</p>
</li>
<li>
<p>100644,普通文件</p>
</li>
<li>
<p>100755,可执行文件</p>
</li>
<li>
<p>120000,符号链接</p>
</li>
</ul>
</li>
<li><code>git cat-file - p</code>查看树对象内容</li>
<li><code>git read-tree -prefix=那么 第一棵树的哈希值</code> name表示新树的名字,将第二颗树加入第一棵树</li>
</ul>
<h6 id="测试如下">测试如下</h6>
<pre><code class="language-git">git update-index --add --cacheinfo 100644 bd721793c916757eb17ffc248799ad00f0b35735 test.txt
git ls-files -s 	#查看暂存区
100644 bd721793c916757eb17ffc248799ad00f0b35735 0       test.txt	#输出

find .git/objects -type f     #查看版本库        
.git/objects/bd/721793c916757eb17ffc248799ad00f0b35735	#输出
.git/objects/89/f9ceab790a0662e30ff1f2f3e8bac0bf7fd895	#输出
#版本库中并没有树对象
git write-tree       #将暂存区的内容写入版本库               
91db0f4cfb1a0eff06a0dd80db40069cebe97332 #树对象的哈希值
git cat-file -t 91db0f4cfb1a0eff06a0dd80db40069cebe97332
tree 	#文件类型,树对象

#此时版本库就有了树对象
find .git/objects -type f
.git/objects/bd/721793c916757eb17ffc248799ad00f0b35735 #&quot;text&quot;的哈希
.git/objects/89/f9ceab790a0662e30ff1f2f3e8bac0bf7fd895 #&quot;test.txt内容的哈希&quot;
.git/objects/91/db0f4cfb1a0eff06a0dd80db40069cebe97332 #树对象的哈希值
</code></pre>
<p>**说明:**git write-tree可以等树对象修改多次后,或者添加删除多次后在执行,这也就是说,树对象能代表项目的一个快照</p>
<p>**总结:**git对象代表每个文件的版本,树对象可以代表项目版本</p>
<h6 id="树对象的构建">树对象的构建</h6>
<p>新建一个gyg.txt 修改 test.txt 将这两个文件塞入暂存区,并生成树对象</p>
<pre><code class="language-git">#新建gyg.txt
echo &quot;new file v1&quot; &gt; gyg.txt
git hash-object -w gyg.txt  #添加新文件的git对象
b2b44573b56f7ea44cbe6e34a69b4f1b19311c5c #gyg.txt的哈希

#修改test.txt的内容
vim test.txt #加入test v2
git hash-object -w ./test.txt  #创建test.txt第二个版本的git对象
6623ae759d09947564e5b45ce93e2633f943cca2

#将test.txt第二个版本塞入暂存区
git update-index --add --cacheinfo 100644 6623ae759d09947564e5b45ce93e2633f943cca2 test.txt  

#查看暂存区
git ls-files -s                    
100644 6623ae759d09947564e5b45ce93e2633f943cca2 0       test.txt
#可以看出将test.txt的第一个版本的记录覆盖掉了(对比上面的记录)

#将gyg.txt塞入暂存区
git update-index --add --cacheinfo 100644 b2b44573b56f7ea44cbe6e34a69b4f1b19311c5c gyg.txt

#查看暂存区
git ls-files -s                
100644 b2b44573b56f7ea44cbe6e34a69b4f1b19311c5c 0       gyg.txt
100644 6623ae759d09947564e5b45ce93e2633f943cca2 0       test.txt
#证明,暂存区的覆盖是根据文件名覆盖的
#生成项目第二个版本的树对象
git write-tree                     
fe52097435752e39aded6f64dbb74746a96e5d4c

#查看版本库
find .git/objects -type f          
.git/objects/66/23ae759d09947564e5b45ce93e2633f943cca2
.git/objects/bd/721793c916757eb17ffc248799ad00f0b35735
.git/objects/89/f9ceab790a0662e30ff1f2f3e8bac0bf7fd895
.git/objects/fe/52097435752e39aded6f64dbb74746a96e5d4c  #workspace第二个树对象
.git/objects/91/db0f4cfb1a0eff06a0dd80db40069cebe97332 	#workspace第一个树对象
.git/objects/b2/b44573b56f7ea44cbe6e34a69b4f1b19311c5c
</code></pre>
<p>树对象目前的状态:</p>
<pre><code class="language-mermaid">graph LR
	tree1(第一个树对象)--&gt;git1[test.txt v1]
	tree2(第二个树对象)--&gt;git2[test.txt v2]
	tree2(第二个树对象)--&gt;git3[gyg.txt v1]
subgraph git
	git1[test.txt v1]
	git2[test.txt v2]
	git3[gyg.txt v1]
	end
</code></pre>
<p>将第一棵树加入第二颗树</p>
<pre><code class="language-git">#先查看暂存区
git ls-files -s                       
100644 b2b44573b56f7ea44cbe6e34a69b4f1b19311c5c 0       gyg.txt
100644 6623ae759d09947564e5b45ce93e2633f943cca2 0       test.txt
#执行加入操作
git read-tree --prefix=bak 91db0f4cfb1a0eff06a0dd80db40069cebe97332 
#查看暂存区变化,可以看出多出了一个新的记录
git ls-files -s                     
100644 bd721793c916757eb17ffc248799ad00f0b35735 0       bak/test.txt
100644 b2b44573b56f7ea44cbe6e34a69b4f1b19311c5c 0       gyg.txt
100644 6623ae759d09947564e5b45ce93e2633f943cca2 0       test.txt
#生成新的树对象
git write-tree                    
403127d92cb74fa3f505adc2d90e1c16932151ab
#查看版本库
find .git/objects -type f           
.git/objects/66/23ae759d09947564e5b45ce93e2633f943cca2
.git/objects/bd/721793c916757eb17ffc248799ad00f0b35735
.git/objects/89/f9ceab790a0662e30ff1f2f3e8bac0bf7fd895
.git/objects/40/3127d92cb74fa3f505adc2d90e1c16932151ab #第三棵树对象
.git/objects/fe/52097435752e39aded6f64dbb74746a96e5d4c #第二个
.git/objects/91/db0f4cfb1a0eff06a0dd80db40069cebe97332 #第一个
.git/objects/b2/b44573b56f7ea44cbe6e34a69b4f1b19311c5c
#查看第三课树的内容,如下:
git cat-file -p 403127d92cb74fa3f505adc2d90e1c16932151ab
040000 tree 91db0f4cfb1a0eff06a0dd80db40069cebe97332    bak
100644 blob b2b44573b56f7ea44cbe6e34a69b4f1b19311c5c    gyg.txt
100644 blob 6623ae759d09947564e5b45ce93e2633f943cca2    test.txt
</code></pre>
<p>此时树对象的状态:</p>
<p>​	tree3右边的其实就是第二棵树,本质上就是第二颗树通过bak指针,连接上了第一棵树</p>
<pre><code class="language-mermaid">graph TB
	git4[第三颗树对象]--bak--&gt;tree1
	git4[第三颗树对象]--gyg.txt--&gt;git3
	git4[第三颗树对象]--test.txt v2--&gt;git2
subgraph tree对象
	tree1(第一个树对象)--&gt;git1[test.txt v1]
	tree2(第二个树对象)--&gt;git2[test.txt v2]
	tree2(第二个树对象)--&gt;git3[gyg.txt v1]
subgraph git对象
	git1[test.txt v1]
	git2[test.txt v2]
	git3[gyg.txt v1]
	end
	end
</code></pre>
<h6 id="树对象的问题">树对象的问题</h6>
<ul>
<li>没有对每个版本所做的事,做出解释</li>
<li>但是若要重用,必须记住哈希值</li>
<li>解决方式:提交对象</li>
</ul>
<h5 id="提交对象">提交对象</h5>
<h6 id="代码说明">代码说明</h6>
<ul>
<li><code>commit-tree 树对象哈希值</code> 创建提交对象</li>
</ul>
<h6 id="测试-2">测试</h6>
<pre><code class="language-git">#前面的表示对这次提交的注释
echo &quot;first commit&quot; | git commit-tree 91db0f4cfb1a0eff06a0dd80db40069cebe97332
7a2b96724dc580540d292862a013a72376a43624
#查看提交对象
git cat-file -p 7a2b96724dc580540d292862a013a72376a43624
tree 91db0f4cfb1a0eff06a0dd80db40069cebe97332	#树对象
author seulG &lt;gengyagexstar1@gmail.com&gt; 1574947028 +0800	#配置好的用户名和邮箱
committer seulG &lt;gengyagexstar1@gmail.com&gt; 1574947028 +0800
first commit	# 注释
</code></pre>
<p>也就是提交对象对树对象做了一次包裹,对树对象作出解释,每个提交对象都需要一个父对象(第一次除外)</p>
<pre><code class="language-git"># 生成第二个提交对象,指定父提交
 echo &quot;second commit&quot; | git commit-tree fe52097435752e39aded6f64dbb74746a96e5d4c -p 7a2b96724dc580540d292862a013a72376a43624
 #这是输出
c9712137be81be7d4cd61640911a5b00ef2f91e3
# 生成第三个提交对象
 echo &quot;third commit&quot; | git commit-tree 403127d92cb74fa3f505adc2d90e1c16932151ab -p c9712137be81be7d4cd61640911a5b00ef2f91e3
 #输出
b91c0ac905ff7fee128de2cf33c3b7923343959e
</code></pre>
<pre><code class="language-mermaid">graph LR

subgraph 提交对象
commit1[first commit] --&gt; tree1
commit2[second commit] --&gt; tree2
commit3[third commit] --&gt; git4
commit3[third commit] --父提交--&gt; commit2
commit2[second commit] --父提交--&gt; commit1
subgraph tree对象
	git4[第三颗树对象]--bak--&gt;tree1
	git4[第三颗树对象]--gyg.txt--&gt;git3
	git4[第三颗树对象]--test.txt v2--&gt;git2
	tree1(第一个树对象)--&gt;git1[test.txt v1]
	tree2(第二个树对象)--&gt;git2[test.txt v2]
	tree2(第二个树对象)--&gt;git3[gyg.txt v1]
subgraph git对象
	git1[test.txt v1]
	git2[test.txt v2]
	git3[gyg.txt v1]
	end
	end
	end
</code></pre>
<h6 id="说明">说明</h6>
<p>真正代表一次项目版本的是提交对象,而代表一个项目快照的是树对象,提交对象只是对树对象的封装,但是<strong>提交对象的是链式</strong>的</p>
<p>至此所有的<code>底层命令已经结束</code>,git数据库的存储不是增量的,需要回退版本,只需要直接找到所需要的版本的提交对象的哈希值,直接跳过去就行</p>
<h3 id="目录说明">目录说明</h3>
<h4 id="git目录">.git目录</h4>
<p>在文件夹下,执行<code>git init</code> 就能初始化一个git仓库,生成一个<code>.git</code>隐藏目录</p>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2019/11/28/UYaTc7eCWrqgtFM.png" alt="dir.png" loading="lazy"></figure>
<p>hooks		——&gt;	客户端或者服务端的钩子脚本</p>
<p>info			——&gt;	包含全局排除文件</p>
<p>logs			——&gt;	保存日志信息</p>
<p>objects	  ——&gt;	存储所有数据内容(版本库)</p>
<p>refs			——&gt;	存储指向数据(分支)的提交对象的指针</p>
<p>config		——&gt;	git配置选项</p>
<p>description ——&gt;  对仓库的描述</p>
<p>HEAD		——&gt;	指示目前被检出的分支</p>
<p>index		  ——&gt;	暂存区保存暂存数据(暂存区)</p>
<figure data-type="image" tabindex="3"><img src="https://upload-images.jianshu.io/upload_images/3139616-d5f236844b57eb2f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/596/format/webp" alt="git" loading="lazy"></figure>
<h4 id="工作目录">工作目录</h4>
<p>建议配合下面的高层命令看这一部分</p>
<ul>
<li>相当于沙箱环境,只要没有git add 或者git hash-object,可以随便修改</li>
<li>工作目录下的文件只有两种状态 <strong>已跟踪</strong> <strong>未跟踪</strong></li>
<li>已跟踪的文件有三个状态,<strong>已提交</strong>,<strong>已修改</strong>,<strong>已暂存</strong>
<ul>
<li>git add 使文件成为已暂存</li>
<li>暂存完,又修改变,该文件,此文件会出现两个状态
<ul>
<li>一个为已暂存</li>
<li>一个为已修改</li>
</ul>
</li>
<li>git commit 使文件变为已提交</li>
<li><code>git diff</code>查看当前哪些更新未暂存</li>
<li><code>git diff –staged</code> 或者 <code>git diff –cached</code> 查看哪些已暂存,等待提交</li>
</ul>
</li>
<li>可以用git status 查看当前文件状态</li>
</ul>
<h3 id="高层命令">高层命令</h3>
<h4 id="git-init-初始化仓库">git init 初始化仓库</h4>
<h4 id="git-add-file">git add  <file></h4>
<h5 id="测试-3">测试</h5>
<pre><code class="language-git">git init
echo &quot;hello world&quot; &gt; gyg.txt
# 查看暂存区
git ls-files -s                     
100644 3b18e512dba79e4c8300dd08aeb37f8e728b8dad 0       gyg.txt
# 查看该git对象内容
git cat-file -p 3b18e512dba79e4c8300dd08aeb37f8e728b8dad
hello world
</code></pre>
<p><strong>git add 将工作目录的修改做成git对象放进版本库,再放入暂存区</strong></p>
<h5 id="说明-2">说明</h5>
<ul>
<li>对工作区修改几个文件就会生成几个git对象</li>
<li>一个对象,修改n次,就出生成n次对象,git不是增量的,而是直接生成新的git对象,旧的git对象也不会删除,会保留在版本库(.git/objects)</li>
<li>git是绝对安全的,尽管没有提交,加入到了暂存区,<strong>使文件变为已暂存状态</strong>,git也能管理,不会丢失数据(找到对应的哈希值就能找回数据)</li>
<li>只有在提交的时候,才会去参照暂存区,做成一个树对象,放入版本库</li>
<li>在你想要添加注释信息的时候,才会把树对象拿出来,添加注释,将其包装成提交对象</li>
<li>git add 实则上执行了 <code>git hash-object -w</code>,和<code>git update-index --add --cacheinfo</code></li>
</ul>
<h3 id="git-commit-m-注释">git commit -m “注释”</h3>
<h4 id="测试-4">测试</h4>
<pre><code class="language-git">git commit -m &quot;注释&quot;
[master（根提交） 3b52ce7] “注释”
 1 file changed, 1 insertion(+)
 create mode 100644 gyg.txt
#查看暂存区,可以看到没有变化
git ls-files -s                        
100644 3b18e512dba79e4c8300dd08aeb37f8e728b8dad 0       gyg.txt
#查看对象数,可以发现有三个对象,一个git对象,一个树对象,一个提交对象
find .git/objects -type f          
.git/objects/3b/18e512dba79e4c8300dd08aeb37f8e728b8dad
.git/objects/3b/52ce7e550af40b74c470afdd1675cf492a3cbe
.git/objects/d0/0870593909003f4669d40cd6d65d0bcd081efe
</code></pre>
<h4 id="说明-3">说明</h4>
<ul>
<li>
<p>可以不加-m参数 , 在打开的vim编辑器里面编辑比较长的注释</p>
</li>
<li>
<p>可以跳过使用暂存区,加上-a选项,git会将所有已跟踪的文件,暂存起来一并提交</p>
</li>
<li>
<p>提交正如上述,版本库的树对象拿出来,然后,添加注释,包装成提交对象</p>
</li>
<li>
<p>git commit 实则上做了<code>git write-tree</code>将暂存区的写入版本库,<code>git commit-tree</code>生成提交对象</p>
</li>
<li>
<p>使文件变为已提交状态,若所有文件都是已提交状态,则 <code>git status</code>不会显示任何内容</p>
</li>
</ul>
<h3 id="git-status">git status</h3>
<p>查看当前文件状态</p>
<ul>
<li>git commit 使文件变为已提交</li>
<li><code>git diff</code>查看当前哪些更新未暂存</li>
<li><code>git diff –staged</code> 或者 <code>git diff –cached</code> 查看哪些已暂存,等待提交</li>
</ul>
<h4 id="测试-5">测试</h4>
<pre><code class="language-git">echo &quot;file1&quot; &gt; file1.txt
git add file1.txt
git status
#输出
1 file changed, 1 insertion(+)
 create mode 100644 file1.txt
#修改文件
vim file1.txt 加入file1 v2
git status
#输出
要提交的变更：
  （使用 &quot;git rm --cached &lt;文件&gt;...&quot; 以取消暂存）
        新文件：   file1.txt
尚未暂存以备提交的变更：
  （使用 &quot;git add &lt;文件&gt;...&quot; 更新要提交的内容）
  （使用 &quot;git restore &lt;文件&gt;...&quot; 丢弃工作区的改动）
        修改：     file1.txt
#出现了两个该文件的状态

git diff
#输出
diff --git a/file1.txt b/file1.txt
index e212970..98e6ed6 100644
--- a/file1.txt
+++ b/file1.txt
@@ -1 +1,2 @@ 
 file1
+file1 v2 
#file1.txt已修改,未暂存
git add file1.txt
</code></pre>
<h2 id="个人理解总结">个人理解总结</h2>
<h3 id="git对象-3">git对象</h3>
<h4 id="git对象blob类型">git对象(blob类型)</h4>
<p>也可以成为数据对象，这个对象只组织数据，不会记录文件。也就是说这个对象只会记录每个文件的内容，并且根据内容生成hash，存入git的数据库(键值对数据库)，这就有一个问题，git对象只能代表每个数据的一个版本，而无法代表一个文件的版本。</p>
<h4 id="树对象tree类型">树对象(tree类型)</h4>
<p>树对象，能将git对象组织起来，并将文件组织起来，从而能够代表一个项目的版本。对于树对象的操作，仍然只能通过hash操作，并且无法显式知道每次对文件作出了什么修改。</p>
<h4 id="提交对象commit类型">提交对象(commit类型)</h4>
<p>提交对象，将树对象封装上自定义的说明，以及git的一些配置信息，如提交用户，提交用户的邮箱。并且会带有其父提交对象的hash(第一个提交对象除外)，可以通过<code>git commit-tree hash -p hash</code>指定父提交对象。能够真正代表一个项目的版本，我们只需要访问提交对象就可以访问到这个版本的所有文件信息以及注释。注意，提交对象是链式的，这就很容易进行回滚版本，直接指向对应的提交对象就相当于回退版本</p>
<h3 id="git三大区域">git三大区域</h3>
<h4 id="暂存区">暂存区</h4>
<p>暂存区存放的是待提交为数对象的git对象，或者是树对象。可以用<code>git ls-files -s</code>查看暂存区的内容。使用<code>git update-index --add --cacheinfo 文件类型[100644普通文件,100755可执行文件,120000符号链接] git对象hash [name]</code>将一个git对象提交到暂存区，如果对一个git对象进行了修改，并且生成了新的git对象，希望将修改后的git都想提交到暂存区，则可以去掉<code>--add</code>参数，并且用同样地名字，进行覆盖。同样可以使用<code>git read-tree prefix=[name] 树对象hash</code>将一个输对象以name的名字提交到暂存区。注意，每次执行<code>write-tree</code>都会将暂存区的所有内容生成一个新的树对象。</p>
<p><strong>注意</strong>暂存区的名字默认与文件名字相同，也就是说暂存区的内容是与文件相对应的</p>
<h4 id="版本库">版本库</h4>
<p>版本库存储了每个提交的三大对象，git对象 、树对象、提交对象这些东西都存储在.git\object文件夹下，且命名方式为，每个对象的hash的前两位作为文件夹，后几位为文件的名字。</p>
<h4 id="工作区">工作区</h4>
<p>工作区就是项目的目录，项目目录的文件除了<code>.git</code>文件夹的内容，只存在两种状态，未跟踪，和未跟踪。工作区是一个沙箱环境，只要是没有 将文件提交给git管理，文件可以做任何修改，这就是未跟踪状态(就不能进行版本控制)。通过<code>git add</code>或者<code>git hash-object</code>将文件提交给git管理，该文件就是已跟踪，此后文件所做的修改都要存入版本库(git对象不是增量的好处)，就可以进行数据的回滚。</p>
<p>已跟踪的文件存在三种状态，已提交，已修改，已暂存。</p>
<h3 id="git高层命令">git高层命令</h3>
<h4 id="git-add">git add</h4>
<p><code>git add</code>做了以下几件事</p>
<ol>
<li>先将修改的数据生成git对象，并存入版本库
<ul>
<li>git hash-object</li>
</ul>
</li>
<li>后将该git对象从版本库存入暂存区
<ul>
<li>git update-index --add --cacheinfo</li>
</ul>
</li>
</ol>
<h4 id="git-commit">git commit</h4>
<p><code>git commit</code>做了以下几件事</p>
<ol>
<li>将暂存区的内容生成树对象
<ul>
<li>git write-tree</li>
</ul>
</li>
<li>将树对象和注释 包装为提交对象
<ul>
<li>git commit-tree</li>
</ul>
</li>
<li>提交并不会清空暂存区</li>
<li>若一次要写的提交注释太长，可以用<code>git commit</code>会打开设定的默认编辑器</li>
</ol>
<h4 id="git-status-2">git status</h4>
<p>会给出工作区的所有文件所处的状态</p>
<ul>
<li>
<p>注意每次修改文件，git并不会自动提交修改的文件，需要手动git add，也就是说，修改已追踪的文件，必须要手动git add 该文件，否则直接提交并不会提交该修改。</p>
</li>
<li>
<p>已跟踪的文件应该执行提交。</p>
</li>
<li>
<p>已修改的文件应该执行git add，或者进行暂存，或者执行git restore进行回退。</p>
</li>
<li>
<p>一个文件可以存在两种状态，在git add后，该文件被标记为已暂存，然后修改该文件，该文件会被标记为已修改，同时存在两种状态。此时提交，只会提交修改的。</p>
</li>
<li>
<p>因为git status显示的信息过于简单，可以通过<code>git diff --staged</code>查看已经暂存待提交的文件</p>
</li>
<li>
<p>跳过暂存区，我们可以使用<code>git commit -m -a</code>跳过使用暂存区，直接把所有已跟踪的文件加入暂存区，并提交，节省了<code>git add</code>的步骤</p>
</li>
</ul>
<h4 id="git-删除操作">git 删除操作</h4>
<p>当删除了工作区的某个文件，该文件就会被标记为已删除，可以通过git add ./将修改存入暂存区，如果此时提交，用户执行的是删除操作，但是git在版本库种执行的仍然是新增操作，新增了一个不包含删除文件的树对象，和该树对象的提交对象</p>
<p>当然上述操作，可以用<code>git rm</code>实现，git rm 会删除指定文件，并将修改存入暂存区，只需要提交修改即可</p>
<h4 id="git-修改文件名字">git 修改文件名字</h4>
<p>直接将文件修改名字，git会将该文件标记为已删除和未跟踪，但是当我们执行<code>git add ./</code>时，git会自动比较两个文件的内容，内容一直就会将该文件标记为renamed</p>
<p>使用<code>git mv</code>快速实现上述操作，能重命名文件，并将修改存入暂存区</p>
<h4 id="git-查看历史记录">git 查看历史记录</h4>
<p><code>git log</code>会显示每个提交对象的hash，注释，以及做了什么操作，作者信息和时间</p>
<p><code>git log --pretty=oneline</code>或者<code>git log --oneline</code>,将每次提交放在一行显示,会隐藏作者信息，并且会显示提交对象hash的前几位</p>
<h3 id="git分支">git分支</h3>
<h4 id="简介">简介</h4>
<p>git的分支就是一个指针(HEAD)。HEAD是一只指向提交对象，每次进行提交操作，HEAD都会进行更新，上面也说了，提交操作是链式的(通过其父提交对象组织)，因此HEAD指针可以很方便的进行版本的回退和切换分支，只要让HEAD指向不同分支的提交对象即可。</p>
<p>每个分支的最新提交对象的hash只存储在ref目录</p>
<h4 id="模型">模型</h4>
<p>git的分支极其高效，我们可以把该模型理解为：每次对项目文件的修改都存在一个链表中，默认一个master分支每次指向最近加入链表的提交对象，HEAD指向master,只有被HEAD指向的指针才能移动，因此创建分支就相当于新加入了一个指针(锚点)，如果新增代码，该分支(锚点)就往前移动，而其他分支由于失去了HEAD的指向，而不能移动。当新的分支做的不行的话，就可以让HEAD指针直接指向master，从而实现代码回退，做的可以就可以直接让master指向新的分支，这就是代码的合并。而这一切建立的基础就是，git的版本库是增量的，每次的修改都是一次新的提交，不会去覆盖之前的提交。</p>
<h4 id="命令">命令</h4>
<ul>
<li>
<p>显示分支列表<code>git branch</code></p>
</li>
<li>
<p>创建分支<code>git branch</code>,会在当前所在的提交对象上创建一个指针，但是此时HEAD并没有指向新的指针</p>
</li>
<li>
<p>切换分支<code>git checkout</code>，会让HEAD指向指定的分支</p>
<ul>
<li>加上<code>-g</code>参数表示新建分支并且换</li>
<li>分支切换会改变HEAD，工作目录的文件，和暂存区的内容</li>
<li>如果git不能干净利落的切换分支，git会禁止切换分支
<ul>
<li>在新分支修改了项目文件，没有执行<code>git add</code>就会禁止切换分支</li>
</ul>
</li>
<li>如果git在新分支上创建了新的未跟踪文件，git允许切换分支，但是该文件也会随着进入新的工作区</li>
<li><strong>最好的方法，每次切换分支查看状态，无状态才切换分支</strong></li>
</ul>
</li>
<li>
<p>删除分支<code>git branch -d</code>不能删除当前HEAD所在的分支</p>
<ul>
<li>若该分支确定不用合并则用-D参数</li>
</ul>
</li>
<li>
<p>查看完整分支历史<code>git log --oneline --decorate --graph --all</code></p>
<ul>
<li>注意老分支看不到完整地log日志，上述命令才可以</li>
</ul>
</li>
<li>
<p>查看每个分支最后一个提交<code>git branch -v</code></p>
</li>
<li>
<p><strong>新建一个分支指向指定的提交对象<code>git branch commitHash</code></strong></p>
<ul>
<li>可以变相的用于回退版本</li>
<li>时光机，版本穿梭</li>
</ul>
</li>
</ul>
<h4 id="配置别名">配置别名</h4>
<p><code>git config --global alias.lol “log --oneline --decorate --graph --all”</code></p>
<p>将上述命令直接用别名 lol替换，不能添加git</p>
<h3 id="合并分支">合并分支</h3>
<p>在分支测试通过之后，就可以将分支合并到主分支上。只能是其他分支，合并到主分支。</p>
<h4 id="快进合并">快进合并</h4>
<p>切换分支步骤：</p>
<ol>
<li>先切换到主分支</li>
<li>执行<code>git merge [branch]</code>将[branch]合并到主分支</li>
<li>合并完的分支可以删除，留着无意义</li>
</ol>
<ul>
<li>直接将master指针指向要合并的分支</li>
<li>会造成 合并前目标分支与master分支之间所产生的分支过期</li>
</ul>
<h4 id="典型合并">典型合并</h4>
<ol>
<li>回到主分支</li>
<li>合并分支</li>
<li>会自动合并代码的修改
<ul>
<li>遇到<strong>冲突</strong>会报错，只能手动解决</li>
<li>手动解决的方式，就是手动打开冲突文件，进行修改，然后<code>git add ./</code>就代表解决了冲突</li>
<li>然后<code>git commit</code>就行了</li>
</ul>
</li>
</ol>
<p>遇到合并冲突的情况，两个平行分支同时修改了同一个文件的同一行代码，注意若是修改同一文件，不一定会造成冲突。</p>
<h4 id="git存储">git存储</h4>
<p>当你在一个分支做了一些工作后，突然想切到其他分支工作，而又不想为一次没有完成的工作做一次提交，这时就可以用到git存储。git存储会把未完成的修改存到一个栈上，我们可以在任何时候重新应用这些改动。</p>
<ul>
<li>git stash 存储</li>
<li>git stash list 查看git存储</li>
</ul>
<p>git存储，本质上是git帮我们做了一次提交，但是该提交没有被记录在日志，而是被存贮在一个栈中。</p>
<ul>
<li>git stash apply  stash@{2} //可以从git stash list查看存储，若不指定，git默认应用最近的一次存储</li>
<li>git stash drop stash@{2}  //应用完存储就可以删除该存储</li>
</ul>
<p>以上操作我们通常使用<code>git stash pop</code>应用并立即删除该存储</p>
<h3 id="git后悔药">git后悔药</h3>
<h4 id="撤回工作区的修改">撤回工作区的修改</h4>
<p>当已被跟踪的文件被修改，想要撤回修改，可以使用<code>git checkout --file</code>，就可以撤回对该文件的修改。</p>
<h4 id="撤回暂存">撤回暂存</h4>
<p>当文件已经被暂存<code>git add</code>，这是文件就被存入了暂存区，此时如果想要撤回该暂存就可以使用<code>git reset HEAD file</code>，可以取消暂存。将该文件从已暂存的状态切换为已修改，此时如果想要撤销文件修改，可以参照 撤回工作区修改</p>
<h4 id="撤回提交">撤回提交</h4>
<ol>
<li>注释写错：当注释写错，就不适用于上面的重新提交。此时可以使用<code>git commit --amend</code>就可以重新修改日志，并自动提交</li>
<li>提交内容错误：如果提交了错误的内容，要先修改错误内容，然后将其加入暂存区，之后再执行<code>git commit --amend</code></li>
</ol>
<p>没有真正撤回提交的方式，只是提供给了我们一次重新写注释的情况</p>
<h4 id="reset三部曲后悔药的实现机制">reset三部曲(后悔药的实现机制)</h4>
<ol>
<li>移动HEAD(包括分支)，checkout是只移动HEAD，而分支指针不会移动。
<ol>
<li><code>git reset --soft HEAD~</code>HEAD~是当前分支上一次提交的别名，页可以直接用提交对象的hash</li>
<li>这种操作，就相当于撤销了一次提交，因为他是连带分支指针一起前移</li>
<li>是<code>git commit --amend</code>所做的操作的实现原理，就是<code>--amend</code>做了一次<code>git reset --soft HEAD~</code>然后在重新提交(会出现分叉)</li>
<li>可以通过<code>git reflog</code>查看HEAD的变化</li>
<li><code>git reset --soft</code>只动了HEAD和分支指针，暂存区和工作目录不受影响</li>
</ol>
</li>
<li>既修改HEAD(包括分支)也修改暂存区，不修改工作区
<ol>
<li><code>git reset [--mixed] HEAD~</code>注：mixed是默认选项，可以不填</li>
<li>此操作不会改变工作区，能撤销暂存区操作</li>
</ol>
</li>
<li>同时修改暂存区、HEAD、工作区
<ol>
<li><code>git reset --hard HEAD~</code>，既修改HEAD(包括分支)，也重置暂存区，也修改工作区</li>
<li>也是reset里面唯一的危险用法，是git能真正销毁数据的几个操作之一，如果工作区存在未跟踪的文件，或者未提交，已修改，但是没有被commit的文件，这个命令会强制覆盖工作区，会销毁上述所说的数据。</li>
<li>在所有数据都<code>commit</code>之后，运行此命令是安全的，因为commit对象会保存工作区的内容。</li>
<li><strong>是<code>git checkout branch</code>的实现原理，只不过checkout不会改变分支，checkout命令给出了相应的保护机制，他不会将未被提交的文件删除，而是带入目标分支。并且，不会移动分支指针</strong></li>
</ol>
</li>
<li>路径reset(只有 --mixed可以跟文件名)
<ol>
<li>如果给reset提供了一个文件路径，他就会跳过移动HEAD，只修改暂存区</li>
<li><strong>其实就是用HEAD里面的内容覆盖掉暂存区的内容(此时HEAD，指向的上次提交，也就是说，HEAD保存了上次提交的暂存区信息)</strong></li>
<li>路径reset的作用范围是仅有该文件的暂存区，不会影响其他文件</li>
<li>这就是回退暂存区的实现原理</li>
</ol>
</li>
<li><code>git checkout file</code>
<ol>
<li>相比于<code>git reset --hard commithash --filename</code>跳过了修改HEAD，暂存区，只修改了工作目录。类比于reset路径。只不过这个命令无法通过语法检查。</li>
<li>本质上是用HEAD里面的工作区信息区强制覆盖工作目录</li>
<li><code>git checkout commitHash file</code>只会跳过移动HEAD，修改暂存区和工作目录</li>
<li><code>git checkout</code>是<code>git reset --hard</code>的变种</li>
</ol>
</li>
</ol>
<h3 id="数据恢复">数据恢复</h3>
<p>当出现了某种状况，我们重置了某个分支，或者删除了他，但是事后又要恢复他。</p>
<ol>
<li>如果是硬重置，直接在reflog里面找到对象的提交对象，再硬重置回去就行</li>
<li>如果是要恢复已删除的分支，也是只需要在reflog找到对应的提交对象，用“版本时光机”，直接用该提交对象的hash创建一个分支就行(更常用)</li>
</ol>
<h3 id="tag">tag</h3>
<h4 id="列出标签">列出标签</h4>
<p><code>git tag {-l tagname*}</code>列出tag或者指定的一个或多标签</p>
<h4 id="创建tag">创建tag</h4>
<p><code>git tag tagname commitHash</code>，给指定的提交对象打上tag</p>
<h4 id="查看特定标签">查看特定标签</h4>
<p><code>git show tagname</code>,列出该标签所在的提交对象的信息</p>
<h3 id="删除tag">删除tag</h3>
<p><code>git tag -d tagname</code>删除指定标签</p>
<h4 id="检出标签">检出标签</h4>
<p><code>git checkout -b tagname</code>此时，HEAD会指向该标签所在提交对象，但是没有创建新分支，处于“分离头指针”的状态，如果此时作出了某些修改，并提交，，tag不会变，但是新的提交不属于任何分支，并且无法访问，除非用hash访问。如果是要修复某个tag版本的错误，则要创建新的分支(指向该标签后，加上**-b**参数)，去修复错误，并将修复后的分支合并到主分支</p>
<h3 id="钩子函数husky">钩子函数(Husky)</h3>
<p>必须先初始化git仓库，然后安装Husky</p>
<h4 id="husky">Husky</h4>
<p>安装<code>npm install husky --save-dev</code>,该模块使用来给git创建钩子的，会默认注册很多钩子</p>
<pre><code class="language-json">// package.json
{
  &quot;husky&quot;: {
    &quot;hooks&quot;: {
      &quot;pre-commit&quot;: &quot;npm test&quot;,
      &quot;pre-push&quot;: &quot;npm test&quot;,
      &quot;...&quot;: &quot;...&quot;
    }
  }
}
</code></pre>
<p>需要在package.json添加上面内容</p>
<p><code>pre-commit</code>提交前执行脚本</p>
<p><code>pre-push</code>push之前执行的脚本</p>
<p>更多钩子查看[githooks]:https://git-scm.com/docs/githooks，但是不支持服务端钩子和<code>pre-receive update post-receive</code></p>
<p><strong>配合Eslint进行代码检查</strong></p>
<h4 id="gitignore">.gitignore</h4>
<p>配置git忽略接管的目录</p>
<h3 id="团队协作">团队协作</h3>
<h4 id="邀请对方协作">邀请对方协作</h4>
<ul>
<li>配置远程仓库别名
<ul>
<li><code>git remote add [别名] 仓库地址</code></li>
<li>这就将远程仓库用别名代替</li>
<li>git push 上传数据</li>
<li>git pull 拉取数据</li>
</ul>
</li>
<li>远程跟踪分支
<ul>
<li>当我们clone一个git仓库，会默认创建一个origin/master远程跟踪分支</li>
<li>可以使用<code>git branch -vv</code>查看远程跟踪分支</li>
<li>当我们用<code>git push 远程库别名 本地分支</code>将本地分支推到远程仓库时，会创建一个远程跟踪分支，但是本地分支没有和该远程跟踪分支绑定</li>
<li>如果此时我们想要把本地修改提交到远程仓库，可以直接<code>git push</code>，前提(已经和远程跟踪分支绑定)</li>
<li>由上述可以看出，如果想要直接<code>git push</code>就必须让本地的分支关联远程跟踪分支。使用<code>git branch -u [仓库别名]/远程仓库分支名</code>将本地已存在的分支绑定远程跟踪分支
<ul>
<li><code>git checkout -b 本地分支名 远程跟踪分支名</code>新建分支并且绑定远程跟踪分支</li>
<li><code>git checkout --track 远程跟踪分支</code>会创建一个鱼远程跟踪分支名字一样的本地分支，并且绑定该分支，前提是先把远程库fetch下来</li>
</ul>
</li>
<li>删除远程分支<code>git origin --delete [分支名]</code></li>
<li>列出仍在远程跟踪，但远程分总已被删除的无用分支<code>git remote origin --dry-run</code></li>
</ul>
</li>
<li>冲突
<ul>
<li>当同时修改同一个文件同一行的时候，后pull的会产生冲突，这样要先将前者的修改pull下载，然后询问对方是否可以修改，自己在本地进行修改后，在提交，然后push上去。这就会被标记为已解决冲突</li>
<li>当远程存在文件，我们又在本地创建了相同文件，需要拉取数据，我们可以先提交，push上去，然后按照上述操作，解决冲突</li>
</ul>
</li>
</ul>
<h4 id="pull-request-fork流程">pull request (fork流程)</h4>
<p>想要参与某个项目但是没有权限</p>
<ul>
<li>参与者先fork 该仓库生成自己的远程仓库，然后去clone自己fork的仓库</li>
<li>然后作出修改，提交到自己的远程仓库</li>
<li>此时可以请求合并自己作出的修改</li>
<li>我们要同步本地和原项目的代码，需要配置别名<code>git remote add [别名] 原项目的地址</code>
<ul>
<li>此时可以重新设置master的远程跟踪分支，先拿到该仓库的更新<code>git fetch 远程仓库别名</code>，需要那个就fetch哪个，然后切换当前分支的远程跟踪分支<code>git branch -u 远程仓库别名/分支名</code>，然后<code>git pull</code>拉去数据</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[递归 -八皇后问题]]></title>
        <id>https://seulg.github.io/post/递归-八皇后问题/</id>
        <link href="https://seulg.github.io/post/递归-八皇后问题/">
        </link>
        <updated>2019-11-25T13:34:29.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="8皇后问题">8皇后问题</h2>
<ul>
<li>问题描述</li>
<li>思路</li>
<li>代码分析</li>
<li>难点</li>
</ul>
<h4 id="问题描述">问题描述</h4>
<p>在国际棋盘上,放置8个皇后,要求,皇后之间不能互相攻击,即不能同一行,不能同一列,不能在对角线</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="8皇后问题">8皇后问题</h2>
<ul>
<li>问题描述</li>
<li>思路</li>
<li>代码分析</li>
<li>难点</li>
</ul>
<h4 id="问题描述">问题描述</h4>
<p>在国际棋盘上,放置8个皇后,要求,皇后之间不能互相攻击,即不能同一行,不能同一列,不能在对角线</p>
<!-- more -->
<h4 id="思路">思路</h4>
<ul>
<li>
<p>第一个皇后放在第一行第一列</p>
</li>
<li>
<p>第二个皇后放在第二行第一列,判断是否满足条件,不满足就放在第二列,第三列……直到找到合适的</p>
</li>
<li>
<p>继续第三个皇后,同样是先第三行第一列,第二列,第三列…….因为是递归,最终会回溯找到一个合适的位置</p>
</li>
<li>
<p>当8歌皇后都放在正确的位置时,在栈上木安回退到上一个栈,就会开始回溯,找到第一个皇后在第一列的所有正确结果</p>
</li>
<li>
<p>然后把第一个皇后放在第二个位置,重复上述步骤</p>
</li>
</ul>
<p><strong>tips :</strong></p>
<p>皇后的位置用一维数组表示,索引表示行数,数值表示列数</p>
<h4 id="代码">代码</h4>
<pre><code class="language-java">package henu.recursion;

public class Queen {
    //定义一个递归调用次数
    public static int num = 0;
    //定义找到的方案的个数
    public static int resNum = 0;
    //定义判断是否冲突的次数
    public static int judgeNum = 0;
    //定义max,皇后数量
    int max = 8;
    //结果数组
    int[] arr = new int[max];
    public static void main(String[] args) {
        Queen queen = new Queen();
        queen.check(0);
        System.out.println(num);
        System.out.println(resNum);
        System.out.println(judgeNum);
    }

    //输出结果
    private void print() {
        resNum++;
        for(int i=0;i&lt;arr.length;i++) {
            System.out.print(arr[i] + &quot; &quot;);
        }
        System.out.println();
    }

    //放置皇后
    private void check(int n) {
        num++;
        //递归终止条件
        if(n == max) {
            print();
            return;
        }
        //依次放入皇后,判断是否冲突
        for(int i=0;i&lt;max;i++) {
            //先把当前皇后 n,放到该行的第一列
            arr[n] = i;
            //判断是否冲突
            if(judge(n)) {
                //不冲突,放置下一个皇后
                check(n+1);
            }
            //冲突,会回溯,把第n个皇后放到下一列(for循环)
        }
    }

    /**
     *
     * @param n 第n个皇后
     * @return
     */
    public boolean judge(int n) {
        judgeNum++;
        for(int i=0;i&lt;n;i++) {
            //位于同一列 , 行差等于列差,判断是否为对角线
            if(arr[i] == arr[n] || Math.abs(n-i) == Math.abs(arr[n]-arr[i])) {
                return false;
            }
        }
        return true;
    }

}

</code></pre>
<pre><code class="language-java">Output:
0 4 7 5 2 6 1 3 
0 5 7 2 6 3 1 4 
0 6 3 5 7 1 4 2 
    ......
7 2 0 5 1 4 6 3 
7 3 0 2 5 1 6 4 
2057
92
15720
</code></pre>
<h4 id="难点">难点</h4>
<p>如何理解,在找到一个正确答案时,会执行思路的第四步?</p>
<ul>
<li>
<p>在把最后一个皇后第一次放在合适的位置时,坐上面的栈return了,会执行下一个置顶栈</p>
</li>
<li>
<p>也就是第7个皇后的位置,然后,挪动第7个皇后,判断是否合适…..</p>
</li>
<li>
<p>第7个没合适的就继续回溯,去改变第6个皇后,以此类推……..</p>
</li>
<li>
<p>最终会找到第一个皇后在第一列时的所有正确方案</p>
</li>
<li>
<p>然后第一个皇后又会放在第二列,重复上述整个过程</p>
</li>
<li>
<p>整个程序执行完毕就是第一个皇后遍历的所有的7列找到所有的合适位置才会最终退出这个程序</p>
</li>
<li>
<p>可以看出,最后程序一共递归了2057次,找到了92种方案,判断了15720次</p>
</li>
</ul>
<p><strong>可以看出递归的资源浪费量巨大</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[递归 -迷宫问题]]></title>
        <id>https://seulg.github.io/post/递归-迷宫问题/</id>
        <link href="https://seulg.github.io/post/递归-迷宫问题/">
        </link>
        <updated>2019-11-25T05:24:58.000Z</updated>
        <content type="html"><![CDATA[<h2 id="迷宫问题">迷宫问题</h2>
<ul>
<li>问题描述</li>
<li>递归的原则</li>
<li>问题分析</li>
<li>代码分析</li>
</ul>
<h4 id="问题描述">问题描述</h4>
<p>用一个二维数组模拟一个迷宫,定义一个入口和出口,找出路径找到通往出口的路径</p>
<p>拓展问题,如何找出最短路径? —待施工……</p>
<h4 id="递归的原则">递归的原则</h4>
<p>递归的应用原则</p>
<ul>
<li>
<p>执行一个方法时,就会创建一个新的受保护的栈空间</p>
</li>
<li>
<p>每个空间的变量都是局部变量(引用传递除外),相互不会影响</p>
</li>
<li>
<p>递归必须向退出递归的条件逼近,否则会无限递归(死龟)</p>
</li>
<li>
<p>当一个方法执行完毕,或者遇到return,就会返回,遵守谁调用,就把结果返回给谁,同时当方法执行完毕或者返回时,该方法就执行完毕</p>
</li>
</ul>
<h4 id="问题分析">问题分析</h4>
<ul>
<li>
<p>迷宫问题,从起点开始,定义一个策略(往四个方向探索的顺序)</p>
</li>
<li>
<p>定义: 0-&gt;表示为探索过的,1-&gt;墙, 2-&gt;通路(已经走过切,能走通), 3-&gt;死路(走过判断为死路)</p>
</li>
<li>
<p>然后递归的结束条件就是出口点被修改为2,如果不满足这个条件就按照策略开始走</p>
</li>
<li>
<p>每当开始探索一个点,就假设,这个点为通路,修改为2,究竟是否为通路,要看回溯的结果</p>
</li>
<li>
<p>如果,一个点上下左右都不能走,就修改为3,表示死路</p>
</li>
</ul>
<h4 id="代码分析">代码分析</h4>
<pre><code class="language-java">/**
     *
     * @param map 迷宫地图,0表示路,1表示墙,2表示通路,3表示死路
     * @param i 迷宫起点
     * @param j
     */
    public static boolean setMap(int[][] map, int i, int j) {
        if(map[6][6] == 2) {
            return true;
        } else {
            if(map[i][j] == 0) {
                map[i][j] = 2;  //假设这个点可以走通,若果不能会回溯
                if(setMap(map, i+1, j)) { //先向下走
                    return true;
                } else if(setMap(map, i, j+1)) { //向右走
                    return true;
                } else if(setMap(map, i-1, j)) { //向上走
                    return true;
                } else if(setMap(map, i, j-1)) { //向左走
                    return true;
                } else { //上下左右都无法走通
                    map[i][j] = 3;
                    return false;
                }
            } else { //可能是1,2,3墙不能走,2表示走过,3表示不能走,这三种情况都是不能走
                return false;
            }
        }
    }
</code></pre>
<p>用一个8*8的迷宫模拟一下,迷宫如下</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">1</th>
<th style="text-align:center">1</th>
<th style="text-align:center">1</th>
<th style="text-align:center">1</th>
<th style="text-align:center">1</th>
<th style="text-align:center">1</th>
<th style="text-align:center">1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">入口</td>
<td style="text-align:center">1</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">出口</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p>执行完毕后</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">1</th>
<th style="text-align:center">1</th>
<th style="text-align:center">1</th>
<th style="text-align:center">1</th>
<th style="text-align:center">1</th>
<th style="text-align:center">1</th>
<th style="text-align:center">1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
<td style="text-align:center"></td>
<td style="text-align:center">2</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">2</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<h4 id="说明">说明</h4>
<p>第二张表,里面的3,就是因为,在坐标(2,2)的点会按照策略先向下走,但是(3,2)点的左,右,下都是墙(1),上面又是通路(2),因此这个向下的调用会返回false,并且标记为死路(3),然后进行策略的下一步,向右</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[初来乍到 -Manjaro]]></title>
        <id>https://seulg.github.io/post/初来乍到-Manjaro/</id>
        <link href="https://seulg.github.io/post/初来乍到-Manjaro/">
        </link>
        <updated>2019-11-24T04:07:45.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="manjaro-kde-的日常使用">Manjaro-kde 的日常使用</h2>
<ol>
<li>
<p>切换国内镜像源</p>
</li>
<li>
<p>安装搜狗输入法</p>
</li>
<li>
<p>安装双显卡驱动(optimus-manager)</p>
</li>
<li>
<p>安装常用软件</p>
</li>
<li>
<p>科学上网</p>
</li>
</ol>
]]></summary>
        <content type="html"><![CDATA[<h2 id="manjaro-kde-的日常使用">Manjaro-kde 的日常使用</h2>
<ol>
<li>
<p>切换国内镜像源</p>
</li>
<li>
<p>安装搜狗输入法</p>
</li>
<li>
<p>安装双显卡驱动(optimus-manager)</p>
</li>
<li>
<p>安装常用软件</p>
</li>
<li>
<p>科学上网</p>
</li>
</ol>
<!-- more -->
<h4 id="切换国内源">切换国内源</h4>
<p>为什么要切换为国内源?  -因为国内源不仅仅拥有更快的访问速度,还有更多的本地化软件,比如deepin-wine-qq,网易云音乐等等</p>
<p>国内源一般推荐使用<a href="http://mirrors.ustc.edu.cn/">ustc</a>或<a href="https://mirrors.tuna.tsinghua.edu.cn/">tuna</a>,两个源分别为中国科技大学源和清华大学源</p>
<p><strong>以清华大学源为例</strong></p>
<ul>
<li>官方仓库地址: <a href="http://repo.archlinuxcn.org/">http://repo.archlinuxcn.org</a></li>
</ul>
<p>使用方法: 在<code>/etc/pacman.conf</code>文件末尾添加以下两行:</p>
<pre><code class="language-linux">[archlinuxcn]
SigLevel = Optional TrustedOnly
Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch
</code></pre>
<p>然后安装<code>archlinuxcn-keyring</code>,即执行<code>sudo pacman -S archlinuxcn-keyring</code></p>
<p><strong>建议</strong></p>
<p>切换为清华源后就执行<code>sudo pacman -Syyu</code>更新一下系统,毕竟<code>多滚少挂,不滚等挂</code></p>
<h4 id="安装搜狗输入法">安装搜狗输入法</h4>
<p>一般的linux的发行版对中文输入法的支持都不是特别友好(<a href="https://www.deepin.org/">deepin</a>除外),这个时候我们就需要一款得心应手的输入法,linux上比较好用的输入法,个人推荐:<a href="https://pinyin.sogou.com/linux/?r=pinyin">搜狗输入法</a></p>
<p>教程开始</p>
<pre><code class="language-python">sudo pacman -S yaourt  # AUR小助手,虽然停止维护了,但是很好用
</code></pre>
<pre><code class="language-python">yaourt -S qtwebkit-bin
</code></pre>
<pre><code class="language-python">sudo pacman -S fcitx fcitx-im fcitx-libpinyin kcm-fcitx fcitx-configtool fcitx-sogoupinyin   fcitx-sunpinyin  # 安装搜狗输入法及其依赖
</code></pre>
<pre><code class="language-python">sudo pacman -U https://arch-archive.tuna.tsinghua.edu.cn/2019/04-29/community/os/x86_64/fcitx-qt4-4.2.9.6-1-x86_64.pkg.tar.xz  # 说明: -U参数是安装本地包,也就是说先把后面的包下载下来,这个是配置输入法的工具
</code></pre>
<pre><code class="language-python">sudo vim /etc/profile # 配置环境 vim 可以替换成你熟悉的文本处理器把下面的添加到末尾 必要时也需要把下面的加入到`/.xporfile
</code></pre>
<pre><code class="language-python">export GTK2_RC_FILES=&quot;$HOME/.gtkrc-2.0&quot;
export LC_CTYPE=zh_CN.UTF-8
export XMODIFIERS=@im=fcitx
export GTK_IM_MODULE=fcitx
export QT_IM_MODULE=fcitx
</code></pre>
<p>然后终端运行<code>qtconfig-qt4</code>找到<code>interface</code>选项,在下面的<code>Defult Input Method</code>改为<code>fcitx</code>然后保存退出</p>
<p>终端执行<code>source /etc/profile</code>,然后重启</p>
<h4 id="安装双显卡驱动">安装双显卡驱动</h4>
<ul>
<li>
<p>为什么要安装驱动?</p>
</li>
<li>
<p>Linux对笔记本双显卡的支持为何如此差?</p>
</li>
<li>
<p>Linux下可能是最好的双显卡解决方案</p>
</li>
</ul>
<p><strong>简单谈谈显卡驱动:</strong></p>
<p>显卡已经相当于一个上了锁的机器,驱动相当于钥匙,就比如在win上,没装独显驱动,怎能体验几千帧的快感,顶住图像处理的压力.在linux下也是如此,也需要安装驱动.</p>
<blockquote>
<p><strong>如果你是台式机,或者你能屏蔽核显,请绕道 ,本教程仅针对N/I双显卡</strong></p>
</blockquote>
<p><strong>如何确定自己是否为双显卡</strong></p>
<p>在<code>win</code>下,随便打开一个<code>光污染游戏</code>(滑稽),打开任务管理器,看看你的核显输出是否为零,为零请绕道,不是零,我希望你能继续看下去</p>
<p><strong>双显卡到底是什么</strong></p>
<p>其实双显卡的工作原理就是,独显负责计算资源,然后通过核显输出到显示屏,在win上NVIDIA给出了一系列技术支持这种方式,包括能源管理,所以你会发现,及时用的独显,也会在没有影响性能的情况下,自动关闭独显</p>
<p><strong>为什么Linux对双显卡的支持差</strong></p>
<p>其实现在主流的方案都是社区做的,主流的方案有<a href="https://wiki.archlinux.org/index.php/Bumblebee">Bumblebee</a>,<a href="https://wiki.archlinux.org/index.php/PRIME">prime</a>,[nvidia-run](<a href="https://wiki.archlinux.org/index.php/NVIDIA_Optimus_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E4%BD%BF%E7%94%A8_nvidia-xrun">https://wiki.archlinux.org/index.php/NVIDIA_Optimus_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E4%BD%BF%E7%94%A8_nvidia-xrun</a>,<a href="https://wiki.archlinux.org/index.php/Nouveau">nouveau</a>这些都是比较成熟的方案,最后一个为NVIDIA开源驱动(默认集成在内核里,性能最差的)<br>
<strong>其实这个标题就是错的</strong><code>为什么Linux对双显卡的支持差</code>,为什么一个做系统的要去适配硬件?按照逻辑也应该是,硬件厂商去适配系统,所以个人认为标题应该为<code>为何Nvidia对Linux支持这么差</code>引用Linux之父<code>Linus Torvalds</code>的一句话<code>So,Nvidia Fuck You</code><a href="https://www.bilibili.com/video/av70951224?from=search&amp;seid=8462594522463754800">av70951224</a></p>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2019/11/24/ZJmlO7bQ6k9p1Nw.png" alt="Nvidia.png" loading="lazy"></figure>
<p><strong><a href="https://github.com/Askannz/optimus-manager">optimus-manager</a>可能是最好的,目前为止</strong></p>
<p>言归正传,<code>optimus-manager</code>支持nvidia闭源驱动的所有功能,支持一件切换显卡(需安装optimus-manager-qt),对<code>SDDM，LightDM，GDM</code>这几个显示管理器支持很好</p>
<p><strong>教程开始-进针对Arch或者Arch分支的发行版</strong></p>
<ol>
<li>如果你之前安装过Nvidia驱动,请删除配置文件<code>sudo rm -f /etc/X11/xorg.conf</code>,如果你和我一样是manjaro用户,请一并删除manjaro生成的配置<code>sudo rm -f /etc/X11/xorg.conf.d/90-mhwd.conf</code>,如果你正在使用<code>bumblebee</code>,请禁用起守护进程<code>sudo systemctl disable bumblebeed.service</code></li>
<li>
<ul>
<li>
<p>gdm管理器用户请安装<code>gdm-prime</code>,<code>yaourt -S gdm-prime</code>并且修改<code>/etc/gdm/custom.conf</code>,将<code>#WaylandEnable=false</code>前面的<code>#</code>去掉 Gnomoe的显示管理器就是gdm</p>
</li>
<li>
<p>sddm用户请修改<code>/etc/sddm.conf</code>,注释掉<code>DisplayCommand</code>和<code>DisplayStopCommand</code>前面加一个<code>#</code>即可</p>
</li>
</ul>
</li>
<li>安装主程序<code>sudo pacman -S optimus-manager optimus-manager-qt</code>如果你没有安装过nvidia驱动,请安装nvidia驱动<code>sudo pacman -S nvidia opencl-nvidia lib32-nvidia-utils lib32-opencl-nvidia mesa lib32-mesa-libgl xf86-video-intel</code> 安装的32为兼容包你或许需要开启软件源 <code>multilib</code></li>
<li>启用optimus-manajer守护进程<code>sudo systemctl enable optimus-manager.service</code></li>
<li>重启</li>
</ol>
<p><strong>至此显卡驱动安装完成</strong></p>
<h4 id="安装常用软件">安装常用软件</h4>
<p>有了强大的AUR自行探索吧仅给出几个常用的</p>
<ul>
<li>Typora &lt;markdown编辑器&gt;</li>
<li>deepin-wein-qq &lt;wine-qq,deepin适配的不错&gt;
<ul>
<li>需要安装gnome-settings-daemon<code>yaourt -S gnome-settings-daemon</code></li>
<li>然后然后将/usr/lib/gsd-xsettings设置为自动启动</li>
</ul>
</li>
<li>wps wps-fonts &lt;国产办公软件,无广告!!!!&gt;</li>
</ul>
<h4 id="科学上网-ssr">科学上网-SSR</h4>
<p>不能讲,不敢讲,我很慌!</p>
<p>自行下载安装合适的版本<a href="https://github.com/qingshuisiyuan/electron-ssr-backup/releases">electron-ssr</a>,安装即可,ssr订阅链接自备</p>
<p>若你无法科学上网,安装<a href="http://marin.jb.free.fr/proxydriver/">proxydriver</a><code>yaourt -S proxydriver</code></p>
<p>浏览器的配置,chrome请安装插件<a href="https://github.com/FelisCatus/SwitchyOmega/releases">SwitchyOmega</a>如果你提示安装失败或者不会安装,可以去看看开发者怎么说</p>
<p>然后可以导入我的<a href="https://pan.baidu.com/s/1Qd2oZX3BB3zmtyUayIFeFg">配置文件</a><code>h11v</code>,或者自行百度配置方案,这个太多了,在这就不过多赘述</p>
]]></content>
    </entry>
</feed>